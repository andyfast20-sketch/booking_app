<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Booking Admin Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light dark;
      --bg: linear-gradient(135deg, #1b2735, #090a0f 60%, #12345b);
      --panel-bg: rgba(255, 255, 255, 0.12);
      --panel-border: rgba(255, 255, 255, 0.18);
      --text-primary: #f8fbff;
      --text-muted: rgba(248, 251, 255, 0.7);
      --accent: #30c3a6;
      --accent-strong: #1da488;
      --danger: #ff6b6b;
      --warning: #ffd166;
      --shadow: 0 18px 40px rgba(8, 16, 44, 0.4);
    }

    * {
      box-sizing: border-box;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Montserrat', sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2.5rem 1.25rem 3.25rem;
    }

    .page-header {
      text-align: center;
      max-width: 960px;
    }

    .page-header h1 {
      font-size: clamp(2rem, 4vw, 2.75rem);
      margin-bottom: 0.25rem;
      letter-spacing: 0.02em;
    }

    .page-header p {
      margin-top: 0;
      color: var(--text-muted);
      font-size: 1.05rem;
    }

    main.panel-grid {
      margin-top: 1.5rem;
      width: min(1000px, 100%);
      display: grid;
      gap: 1.25rem;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    main.panel-grid[data-active-panel] {
      grid-template-columns: minmax(0, 1fr);
    }

    main.panel-grid[data-active-panel] > .panel {
      display: none;
    }

    main.panel-grid[data-active-panel] > .panel.panel--solo {
      display: flex;
    }

    .panel {
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
      padding: clamp(1.25rem, 1.75vw, 1.75rem);
      box-shadow: var(--shadow);
      backdrop-filter: blur(16px);
      min-height: 180px;
      overflow: hidden;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .panel[data-expanded="true"] {
      grid-column: 1 / -1;
      transform: translateY(-4px);
      box-shadow: 0 30px 60px rgba(8, 16, 44, 0.55);
      overflow: visible;
    }

    .panel:not([data-expanded="true"]):hover {
      transform: translateY(-3px);
      box-shadow: 0 18px 45px rgba(8, 16, 44, 0.45);
    }

    .image-library-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 1rem;
      margin-top: 0.75rem;
    }

    .image-library-card {
      border: 1px solid rgba(255, 255, 255, 0.16);
      border-radius: 16px;
      padding: 0.85rem;
      background: rgba(0, 0, 0, 0.16);
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease;
    }

    .image-library-card.is-drop-target {
      border-color: rgba(48, 195, 166, 0.65);
      box-shadow: 0 18px 42px rgba(48, 195, 166, 0.18);
      transform: translateY(-2px);
    }

    .image-library-thumb {
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 12px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.08);
      display: grid;
      place-items: center;
      position: relative;
    }

    .image-library-card.is-drop-target .image-library-thumb::after {
      content: 'Drop to replace';
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(16, 24, 40, 0.62);
      color: var(--text-primary);
      font-weight: 700;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      font-size: 0.82rem;
      border: 2px dashed rgba(48, 195, 166, 0.6);
      border-radius: 12px;
    }

    .image-library-grid.is-drop-target {
      outline: 2px dashed rgba(48, 195, 166, 0.75);
      outline-offset: 10px;
      border-radius: 18px;
    }

    .image-library-thumb img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
      background: rgba(255, 255, 255, 0.04);
    }

    .image-library-meta {
      display: grid;
      gap: 0.25rem;
    }

    .image-library-meta strong {
      font-size: 0.92rem;
      word-break: break-word;
    }

    .image-library-meta small {
      color: var(--text-muted);
    }

    .image-library-meta .image-library-usage {
      color: rgba(210, 255, 243, 0.85);
    }

    .image-library-card.is-unmapped .image-library-meta .image-library-usage {
      color: rgba(255, 255, 255, 0.6);
    }

    .image-library-card.is-unmapped {
      border-style: dashed;
    }

    .image-library-actions {
      display: grid;
      gap: 0.5rem;
    }

    .image-library-actions input[type="file"] {
      width: 100%;
      padding: 0.55rem 0.65rem;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(0, 0, 0, 0.12);
      color: var(--text-primary);
    }

    .image-library-toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      margin-top: 0.25rem;
    }

    .image-library-toolbar .input-note {
      margin: 0;
    }

    .panel-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .panel-summary {
      margin-top: 0.85rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .panel-summary-highlight {
      font-size: 1.05rem;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: 0.01em;
    }

    .panel-summary-note {
      color: var(--text-muted);
      font-size: 0.88rem;
      line-height: 1.45;
    }

    .panel[data-expanded="true"] .panel-summary {
      display: none;
    }

    .panel-body {
      margin-top: 1.1rem;
      opacity: 0;
      transform: translateY(-8px);
      transition: opacity 0.25s ease, transform 0.25s ease;
    }

    .panel-body[hidden] {
      display: none !important;
    }

    .panel[data-expanded="true"] .panel-body {
      opacity: 1;
      transform: translateY(0);
    }

    .panel-section {
      margin-bottom: 1.75rem;
    }

    .panel-section:last-child {
      margin-bottom: 0;
    }

    .panel-subheading {
      margin: 0 0 0.75rem;
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    .panel-header h2 {
      margin: 0;
      font-size: 1.4rem;
    }

    .panel-header p {
      margin: 0;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .panel-header .meta {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .panel-actions {
      display: flex;
      gap: 0.65rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .autopilot-status-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 1.25rem;
    }

    .autopilot-provider-row {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .autopilot-provider-row select {
      min-width: 260px;
      flex: 1;
    }

    .autopilot-api-row {
      display: flex;
      gap: 0.65rem;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .autopilot-api-row input {
      min-width: 220px;
      flex: 1;
    }

    .autopilot-api-card {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 1rem 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      box-shadow: 0 12px 32px rgba(8, 16, 44, 0.25);
    }

    .autopilot-api-card .autopilot-api-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.65rem;
      flex-wrap: wrap;
    }

    .autopilot-api-card .autopilot-api-title {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.01em;
    }

    .autopilot-api-card .autopilot-api-description {
      margin: 0.2rem 0 0;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .api-key-list {
      list-style: none;
      padding: 0;
      margin: 0.35rem 0 0;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .api-key-pill {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 999px;
      padding: 0.35rem 0.7rem;
      display: flex;
      flex-direction: column;
      gap: 0.05rem;
      font-size: 0.9rem;
    }

    .api-key-pill strong {
      letter-spacing: 0.02em;
    }

    .api-key-pill small {
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    .eyebrow {
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.4rem 0.85rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.14);
      border: 1px solid rgba(255, 255, 255, 0.22);
      font-size: 0.82rem;
      letter-spacing: 0.02em;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
    }

    .status-pill.active {
      background: rgba(48, 195, 166, 0.22);
      border-color: rgba(48, 195, 166, 0.5);
      color: var(--accent);
      box-shadow: 0 8px 22px rgba(48, 195, 166, 0.28);
    }

    .status-pill.offline {
      background: rgba(255, 107, 107, 0.18);
      border-color: rgba(255, 107, 107, 0.45);
      color: #ffd3d3;
    }

    .autopilot-controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .input-note {
      margin: 0.4rem 0 0;
      color: var(--text-muted);
      font-size: 0.92rem;
      line-height: 1.4;
    }

    .input-note.warning {
      color: var(--warning);
    }

    .autopilot-controls .panel-actions {
      justify-content: flex-end;
    }

    .panel-toggle {
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: rgba(255, 255, 255, 0.12);
      font-weight: 600;
      padding: 0.55rem 1.25rem;
    }

    .panel-toggle[data-state="expanded"] {
      background: rgba(48, 195, 166, 0.2);
      border-color: rgba(48, 195, 166, 0.45);
      color: var(--accent);
      box-shadow: 0 0 0 1px rgba(48, 195, 166, 0.35);
    }

    button,
    input,
    select,
    textarea {
      font: inherit;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1.2rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      background: rgba(255, 255, 255, 0.14);
      color: var(--text-primary);
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    button.primary {
      background: var(--accent);
      color: #031621;
      font-weight: 600;
      box-shadow: 0 14px 30px rgba(48, 195, 166, 0.45);
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.18);
      border: 1px solid rgba(255, 255, 255, 0.24);
      font-weight: 600;
    }

    button.danger {
      background: rgba(255, 107, 107, 0.18);
      color: #ffd3d3;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 26px rgba(3, 9, 24, 0.35);
    }

    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button.danger:hover {
      box-shadow: 0 12px 26px rgba(255, 107, 107, 0.35);
    }

    .table-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .table-action {
      padding: 0.45rem 0.85rem;
      font-size: 0.78rem;
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .table-action:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(48, 195, 166, 0.3);
      background: rgba(48, 195, 166, 0.18);
    }

    .table-action.secondary {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .table-action.secondary:hover {
      box-shadow: 0 12px 24px rgba(3, 9, 24, 0.25);
      background: rgba(255, 255, 255, 0.18);
    }

    .table-action.danger {
      background: rgba(255, 107, 107, 0.18);
      border-color: rgba(255, 107, 107, 0.35);
      color: #ffd3d3;
    }

    .table-action.danger:hover {
      box-shadow: 0 12px 24px rgba(255, 107, 107, 0.35);
      background: rgba(255, 107, 107, 0.26);
    }

    .table-action:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .table-action:focus-visible {
      outline: 2px solid rgba(48, 195, 166, 0.65);
      outline-offset: 2px;
    }

    .visitor-status {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(255, 255, 255, 0.08);
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .visitor-status.allowed {
      background: rgba(48, 195, 166, 0.18);
      border-color: rgba(48, 195, 166, 0.32);
      color: #b6f6e9;
    }

    .visitor-status.banned {
      background: rgba(255, 107, 107, 0.2);
      border-color: rgba(255, 107, 107, 0.4);
      color: #ffd6d6;
    }

    .table-scroll {
      overflow-x: auto;
      margin-top: 1rem;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 640px;
      color: var(--text-primary);
    }

    thead {
      background: rgba(255, 255, 255, 0.12);
    }

    th,
    td {
      padding: 0.85rem 1rem;
      text-align: left;
    }

    th {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(248, 251, 255, 0.75);
    }

    tbody tr:nth-child(even) td {
      background: rgba(0, 0, 0, 0.2);
    }

    tbody tr:nth-child(odd) td {
      background: rgba(0, 0, 0, 0.28);
    }

    .cell-main {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    .cell-main strong {
      font-size: 1rem;
    }

    .cell-muted {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.3rem 0.65rem;
      border-radius: 999px;
      background: rgba(48, 195, 166, 0.18);
      color: var(--accent);
      font-size: 0.82rem;
      font-weight: 600;
    }

    .presence-note {
      margin-bottom: 1rem;
      padding: 0.85rem 1.1rem;
      border-radius: 12px;
      background: rgba(48, 195, 166, 0.16);
      color: var(--text-primary);
      text-align: left;
      font-size: 0.95rem;
      line-height: 1.4;
      border: 1px solid rgba(48, 195, 166, 0.35);
    }

    .visitor-invite-btn {
      border: none;
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      font-weight: 600;
      font-size: 0.85rem;
      background: linear-gradient(135deg, #2e7d32 0%, #1b5e20 100%);
      color: #ffffff;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
      box-shadow: 0 10px 18px rgba(46, 125, 50, 0.25);
    }

    .visitor-invite-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, #388e3c 0%, #2e7d32 100%);
      transform: translateY(-1px);
    }

    .visitor-invite-btn:disabled {
      background: linear-gradient(135deg, #bdbdbd 0%, #9e9e9e 100%);
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .chat-dashboard {
      display: grid;
      grid-template-columns: minmax(220px, 280px) minmax(0, 1fr);
      gap: 1.35rem;
      margin-top: 1.25rem;
    }

    .chat-session-list {
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      min-height: 360px;
    }

    .chat-session-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
    }

    .chat-session-scroll {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      padding-right: 6px;
      max-height: 360px;
      overflow-y: auto;
    }

    .chat-sessions-empty {
      border: 1px dashed rgba(255, 255, 255, 0.3);
      border-radius: 14px;
      padding: 1.15rem;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 200px;
    }

    .chat-session {
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.25);
      color: var(--text-primary);
      padding: 0.8rem 0.95rem;
      text-align: left;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    .chat-session:hover {
      transform: translateY(-2px);
      box-shadow: 0 14px 28px rgba(3, 9, 24, 0.35);
      border-color: rgba(48, 195, 166, 0.45);
    }

    .chat-session.active {
      border-color: rgba(48, 195, 166, 0.7);
      background: rgba(48, 195, 166, 0.18);
      box-shadow: 0 18px 36px rgba(48, 195, 166, 0.3);
    }

    .chat-session-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      font-size: 0.95rem;
    }

    .chat-session-title span {
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .chat-session-preview {
      margin-top: 0.4rem;
      font-size: 0.88rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    .chat-session-meta {
      margin-top: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      font-size: 0.75rem;
      color: rgba(248, 251, 255, 0.65);
    }

    .badge-unread {
      display: inline-flex;
      align-items: center;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      background: rgba(255, 209, 102, 0.25);
      color: var(--warning);
    }

    .chat-session-close {
      margin-left: auto;
      background: rgba(255, 255, 255, 0.14);
      color: var(--text-primary);
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      padding: 0.3rem 0.7rem;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
    }

    .chat-session-close:hover,
    .chat-session-close:focus-visible {
      background: rgba(255, 255, 255, 0.22);
      border-color: rgba(255, 255, 255, 0.35);
      outline: none;
    }

    .chat-thread {
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(0, 0, 0, 0.28);
      display: flex;
      flex-direction: column;
      min-height: 360px;
    }

    .chat-thread[hidden] {
      display: none;
    }

    .chat-thread-wrapper {
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
    }

    .chat-thread-header {
      padding: 1rem 1.25rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.12);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.85rem;
    }

    .chat-thread-header h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .chat-thread-header p {
      margin: 0.3rem 0 0;
      color: var(--text-muted);
      font-size: 0.82rem;
      line-height: 1.35;
    }

    .chat-thread-messages {
      padding: 1.05rem 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      max-height: 280px;
      overflow-y: auto;
    }

    .chat-thread-empty {
      border: 1px dashed rgba(255, 255, 255, 0.25);
      border-radius: 14px;
      padding: 1.8rem 1.3rem;
      text-align: center;
      color: rgba(248, 251, 255, 0.7);
      font-size: 0.92rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      align-items: center;
      justify-content: center;
      min-height: 240px;
    }

    .chat-thread-empty i {
      font-size: 2rem;
      color: var(--accent);
    }

    .thread-message {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      max-width: 74%;
    }

    .thread-message.from-visitor {
      align-self: flex-start;
    }

    .thread-message.from-admin {
      align-self: flex-end;
    }

    .thread-message-bubble {
      padding: 0.85rem 1rem;
      border-radius: 16px;
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.12);
      line-height: 1.55;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .thread-message.from-admin .thread-message-bubble {
      background: linear-gradient(135deg, rgba(48, 195, 166, 0.72), rgba(29, 164, 136, 0.9));
      color: #031621;
      border-color: rgba(48, 195, 166, 0.65);
      box-shadow: 0 14px 32px rgba(48, 195, 166, 0.35);
    }

    .thread-message.autopilot .thread-message-bubble {
      background: linear-gradient(135deg, rgba(48, 195, 166, 0.3), rgba(29, 164, 136, 0.65));
      color: var(--text-primary);
      border-color: rgba(48, 195, 166, 0.48);
      box-shadow: 0 16px 34px rgba(48, 195, 166, 0.32);
    }

    .thread-message.autopilot .thread-message-meta {
      color: rgba(48, 195, 166, 0.85);
    }

    .thread-message-meta {
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .chat-reply-form {
      margin-top: auto;
      border-top: 1px solid rgba(255, 255, 255, 0.12);
      padding: 0.95rem 1.2rem 1.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .chat-reply-form textarea {
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(0, 0, 0, 0.35);
      color: var(--text-primary);
      padding: 0.7rem 0.85rem;
      font-size: 0.92rem;
      min-height: 90px;
      resize: vertical;
    }

    .chat-reply-form textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(48, 195, 166, 0.35);
    }

    .chat-reply-form.disabled textarea,
    .chat-reply-form.disabled button {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .chat-reply-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.65rem;
    }

    .chat-reply-status {
      font-size: 0.82rem;
      color: var(--text-muted);
    }

    .chat-status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.3rem 0.75rem;
      border-radius: 999px;
      background: rgba(48, 195, 166, 0.22);
      color: var(--accent);
      font-weight: 600;
      letter-spacing: 0.04em;
      font-size: 0.82rem;
      text-transform: uppercase;
    }

    .chat-status-indicator::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 0 6px rgba(48, 195, 166, 0.28);
    }

    .chat-status-indicator.offline {
      background: rgba(255, 107, 107, 0.22);
      color: var(--danger);
    }

    .chat-status-indicator.offline::before {
      background: var(--danger);
      box-shadow: 0 0 0 6px rgba(255, 107, 107, 0.28);
    }

    .chat-attention-indicator {
      display: none;
      align-items: center;
      gap: 0.35rem;
      padding: 0.3rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 209, 102, 0.22);
      color: var(--warning);
      font-weight: 700;
      letter-spacing: 0.04em;
      font-size: 0.78rem;
      text-transform: uppercase;
    }

    .chat-attention-indicator::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--warning);
      box-shadow: 0 0 0 6px rgba(255, 209, 102, 0.32);
    }

    .chat-attention-indicator.visible {
      display: inline-flex;
      animation: chat-alert-pulse 1.1s ease-in-out infinite;
    }

    @keyframes chat-alert-pulse {
      0%,
      100% {
        box-shadow: 0 0 0 0 rgba(255, 209, 102, 0.25);
      }
      50% {
        box-shadow: 0 0 0 8px rgba(255, 209, 102, 0.1);
      }
    }

    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .badge.new {
      background: rgba(255, 209, 102, 0.2);
      color: var(--warning);
    }

    .badge.done {
      background: rgba(48, 195, 166, 0.22);
      color: var(--accent);
    }

    .empty-state {
      margin-top: 1.25rem;
      padding: 1.6rem;
      text-align: center;
      border-radius: 14px;
      border: 1px dashed rgba(255, 255, 255, 0.3);
      color: rgba(248, 251, 255, 0.8);
      font-style: italic;
    }

    form.grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.9rem;
      margin-top: 1.1rem;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      font-weight: 600;
      color: var(--text-muted);
      font-size: 0.88rem;
    }

    input,
    select,
    textarea {
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 0.7rem 0.85rem;
      background: rgba(255, 255, 255, 0.15);
      color: var(--text-primary);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    input:focus,
    select:focus,
    textarea:focus {
      border-color: var(--accent);
      outline: none;
      box-shadow: 0 0 0 2px rgba(48, 195, 166, 0.35);
    }

    textarea {
      resize: vertical;
      min-height: 120px;
    }

    .availability-list {
      margin-top: 1rem;
      display: grid;
      gap: 0.7rem;
    }

    .availability-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.65rem 0.9rem;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .customer-slots-grid {
      display: grid;
      gap: 1.25rem;
    }

    .customer-slot-list {
      margin-top: 0.5rem;
      display: grid;
      gap: 0.85rem;
    }

    .customer-slot-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      align-items: center;
      gap: 0.75rem;
      padding: 0.85rem 1rem;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.22);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .customer-slot-meta {
      display: grid;
      gap: 0.35rem;
    }

    .customer-slot-actions {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .customer-slot-actions button {
      padding: 0.45rem 0.75rem;
      font-size: 0.9rem;
    }

    .customer-slot-detail {
      color: var(--text-muted);
      font-size: 0.9rem;
      margin: 0;
    }

    .customer-access-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      align-items: end;
      gap: 0.75rem;
    }

    .quick-picks {
      margin-top: 1rem;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 16px;
      padding: 1rem 1.25rem;
      display: grid;
      gap: 1rem;
    }

    .quick-picks-group {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }

    .quick-picks-label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .quick-picks-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .quick-picks-buttons button {
      background: rgba(255, 255, 255, 0.14);
      border: 1px solid rgba(255, 255, 255, 0.18);
      padding: 0.45rem 0.9rem;
      font-size: 0.85rem;
      border-radius: 999px;
    }

    .quick-picks-buttons button.active {
      background: rgba(48, 195, 166, 0.22);
      border-color: rgba(48, 195, 166, 0.45);
      color: #d2fff3;
      box-shadow: 0 10px 20px rgba(48, 195, 166, 0.25);
    }

    .quick-action {
      margin-top: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .quick-action-note {
      margin: 0;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    dialog {
      border: none;
      border-radius: 18px;
      padding: clamp(1.35rem, 2.5vw, 2rem);
      background: rgba(12, 22, 38, 0.92);
      color: var(--text-primary);
      width: min(480px, 90vw);
      box-shadow: 0 30px 80px rgba(6, 10, 30, 0.55);
    }

    dialog::backdrop {
      background: rgba(3, 6, 16, 0.75);
      backdrop-filter: blur(4px);
    }

    dialog h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
    }

    .dialog-actions {
      margin-top: 1.25rem;
      display: flex;
      justify-content: space-between;
      gap: 0.65rem;
      flex-wrap: wrap;
    }

    .dialog-actions .right {
      display: flex;
      gap: 0.65rem;
    }

    .form-feedback {
      margin-top: 1rem;
      padding: 0.65rem 0.9rem;
      border-radius: 12px;
      background: rgba(255, 107, 107, 0.18);
      color: #ffd3d3;
      display: none;
    }

    .form-feedback.visible {
      display: block;
    }

    .form-feedback.success {
      background: rgba(48, 195, 166, 0.22);
      color: #d2fff3;
    }

    @media (max-width: 720px) {
      body {
        padding: 1.75rem 0.9rem 2.5rem;
      }

      main.panel-grid {
        grid-template-columns: 1fr;
      }

      .panel {
        min-height: 180px;
      }

      table {
        min-width: 540px;
      }

      .panel-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .panel-actions {
        width: 100%;
        justify-content: flex-start;
      }

      .chat-dashboard {
        grid-template-columns: 1fr;
      }

      .chat-session-list {
        min-height: auto;
      }

      .chat-thread {
        min-height: 320px;
      }
    }
  </style>
</head>
<body>
  <header class="page-header">
    <h1>Booking Operations Hub</h1>
    <p>Review, edit or remove bookings, manage available slots and keep on top of new enquiries.</p>
    <button id="logoutBtn" style="position: absolute; top: 20px; right: 20px; background: rgba(255,107,107,0.9); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.2); backdrop-filter: blur(10px);">ðŸ”’ Logout</button>
  </header>

  <main class="panel-grid">
    <section class="panel" aria-labelledby="bookings-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="bookings-heading">Confirmed bookings</h2>
          <p>Live feed of every booking submitted via your website.</p>
        </div>
        <div class="panel-actions">
          <button id="refreshBookings" type="button">Refresh</button>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="bookingsPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="bookingsSummaryHighlight">Instantly view confirmed jobs as they land.</p>
        <p class="panel-summary-note">Expand to review customer details, edit appointments and remove bookings.</p>
      </div>
      <div class="panel-body" id="bookingsPanelBody" hidden>
        <div id="bookingsTable" class="empty-state">Loading bookingsâ€¦</div>
      </div>
    </section>

    <section class="panel" aria-labelledby="presence-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="presence-heading">Live visitors</h2>
          <p>See who is currently browsing and where they are connecting from.</p>
        </div>
        <div class="panel-actions">
          <button id="refreshPresence" type="button">Refresh</button>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="presencePanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="presenceSummaryHighlight">Track who is browsing in real time.</p>
        <p class="panel-summary-note">Expand to see visitor locations, pages and invite them into a chat.</p>
      </div>
      <div class="panel-body" id="presencePanelBody" hidden>
        <div class="panel-section">
          <h3 class="panel-subheading">Active visitors</h3>
          <div id="onlineVisitors" class="empty-state">Checking for active visitorsâ€¦</div>
        </div>
        <div class="panel-section">
          <h3 class="panel-subheading">Index visitor history</h3>
          <p class="panel-summary-note">
            Every visit to your homepage is saved here automatically. Use it to understand who has reached your site.
          </p>
          <div id="visitorHistory" class="empty-state">Loading visitor historyâ€¦</div>
        </div>
      </div>
    </section>

    <section class="panel" aria-labelledby="chat-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="chat-heading">Live chat</h2>
          <p>Manage real-time conversations from the website chat button.</p>
        </div>
        <div class="panel-actions">
          <span class="chat-status-indicator" id="chatStatusIndicator">Chat online</span>
          <span
            class="chat-attention-indicator"
            id="chatWaitingAlert"
            role="status"
            aria-live="polite"
            aria-hidden="true"
          >
            Visitor waiting to chat
          </span>
          <button id="toggleChatStatus" type="button">Go offline</button>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="chatPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="chatSummaryHighlight">Respond instantly to new live chats.</p>
        <p class="panel-summary-note">Expand to view conversation threads, unread messages and send replies.</p>
      </div>
      <div class="panel-body" id="chatPanelBody" hidden>
        <div class="chat-dashboard">
          <aside class="chat-session-list" aria-label="Website chat sessions">
            <div class="chat-session-list-header">
              <h3 style="margin: 0; font-size: 1rem;">Visitors</h3>
              <button type="button" id="refreshChatSessions">Refresh</button>
            </div>
            <div id="chatSessionsContainer" class="chat-sessions-empty">Loading conversationsâ€¦</div>
          </aside>
          <div class="chat-thread-wrapper">
            <div class="chat-thread-empty" id="chatThreadEmpty">
              <i class="fas fa-comments"></i>
              <p>Select a visitor on the left to open their conversation.</p>
            </div>
            <div class="chat-thread" id="chatThread" hidden>
              <div class="chat-thread-header">
                <div>
                  <h3 id="chatThreadTitle">Visitor</h3>
                  <p id="chatThreadMeta"></p>
                </div>
              </div>
              <div class="chat-thread-messages" id="chatThreadMessages"></div>
              <form class="chat-reply-form" id="chatReplyForm" novalidate>
                <label for="chatReplyInput" class="sr-only">Type your reply</label>
                <textarea id="chatReplyInput" rows="3" placeholder="Write a replyâ€¦" required></textarea>
                <div class="chat-reply-actions">
                  <span id="chatReplyStatus" class="chat-reply-status"></span>
                  <button type="submit" class="primary">Send reply</button>
                </div>
              </form>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel" aria-labelledby="autopilot-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="autopilot-heading">Chat autopilot</h2>
          <p>Let an AI assistant answer routine visitor questions using your business knowledge.</p>
        </div>
        <div class="panel-actions">
          <button type="button" id="autopilotToggle">Enable autopilot</button>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="autopilotPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="autopilotSummaryHighlight">Automate FAQs with a tailored assistant.</p>
        <p class="panel-summary-note">Expand to edit your business guide and control the chat autopilot.</p>
      </div>
      <div class="panel-body" id="autopilotPanelBody" hidden>
        <div class="autopilot-status-row">
          <span class="status-pill offline" id="autopilotStatusBadge">Autopilot paused</span>
          <div class="panel-actions">
            <button type="button" id="autopilotToggleSecondary">Enable autopilot</button>
          </div>
        </div>
        <form id="autopilotForm" class="autopilot-controls">
          <label for="autopilotPrompt">
            Business knowledge base
            <textarea
              id="autopilotPrompt"
              name="business_profile"
              maxlength="4000"
              placeholder="Describe your services, service area, pricing guidance, tone of voice and any FAQs you want the assistant to know."
            ></textarea>
          </label>

          <div class="autopilot-api-card" role="group" aria-labelledby="autopilotWebsiteHeading">
            <div class="autopilot-api-header">
              <div>
                <p class="eyebrow">Website knowledge</p>
                <h3 id="autopilotWebsiteHeading" class="autopilot-api-title">Scrape your website</h3>
                <p class="autopilot-api-description">
                  Add your website address and fetch useful business details automatically. This is used alongside your manual notes.
                </p>
              </div>
              <span class="status-pill offline" id="autopilotWebsiteStatus">Not scraped yet</span>
            </div>
            <label for="autopilotWebsiteUrl">
              <div class="autopilot-api-row">
                <input
                  id="autopilotWebsiteUrl"
                  name="business_website_url"
                  type="url"
                  inputmode="url"
                  autocomplete="off"
                  spellcheck="false"
                  placeholder="https://yourwebsite.com"
                />
                <button type="button" id="autopilotWebsiteScrape" class="secondary">Scrape</button>
                <button type="button" id="autopilotWebsiteClear" class="secondary">Clear</button>
              </div>
            </label>
            <p class="input-note" id="autopilotWebsiteNote">
              Tip: use your homepage URL. We'll crawl internal pages on the same domain and skip any /admin areas. (Localhost/private URLs are blocked unless enabled on the server.)
            </p>
            <div class="saved-keys">
              <p class="eyebrow">Scrape preview</p>
              <p class="input-note" id="autopilotWebsiteMeta">No website knowledge saved yet.</p>
              <textarea id="autopilotWebsitePreview" rows="6" readonly placeholder="Scraped text will appear here."></textarea>
            </div>
          </div>

          <div class="autopilot-api-card" role="group" aria-labelledby="autopilotProviderHeading">
            <div class="autopilot-api-header">
              <div>
                <p class="eyebrow">Default provider</p>
                <h3 id="autopilotProviderHeading" class="autopilot-api-title">Autopilot reply source</h3>
                <p class="autopilot-api-description">Choose which provider should generate automatic live chat replies.</p>
              </div>
            </div>
            <label for="autopilotProvider">
              <div class="autopilot-provider-row">
                <select id="autopilotProvider" name="provider">
                  <option value="deepseek">DeepSeek (direct)</option>
                  <option value="openrouter">OpenRouter</option>
                </select>
              </div>
            </label>
            <p class="input-note">You can save keys for both providers below, then switch the default at any time.</p>
          </div>
          <div class="autopilot-api-card" role="group" aria-labelledby="autopilotApiKeyHeading">
            <div class="autopilot-api-header">
              <div>
                <p class="eyebrow">AI access</p>
                <h3 id="autopilotApiKeyHeading" class="autopilot-api-title">DeepSeek API key</h3>
                <p class="autopilot-api-description">Used when the default provider is set to DeepSeek (direct).</p>
              </div>
              <span class="status-pill offline" id="autopilotApiKeyStatus">No key saved</span>
            </div>
            <label for="autopilotApiKey">
              <div class="autopilot-api-row">
                <input
                  id="autopilotApiKey"
                  name="api_key"
                  type="password"
                  inputmode="text"
                  autocomplete="off"
                  spellcheck="false"
                  placeholder="sk-..."
                />
                <button type="button" id="clearAutopilotApiKey" class="secondary">Remove key</button>
              </div>
            </label>
            <p class="input-note" id="autopilotApiKeyNote">
              Saved securely on the server for autopilot replies. Leave blank to keep your existing key or use the
              remove button above. The <code>DEEPSEEK_API_KEY</code> environment variable (or <code>OPENAI_API_KEY</code>
              for legacy setups) will be used as a fallback if no key is saved.
            </p>
            <div class="saved-keys">
              <p class="eyebrow">Saved API keys</p>
              <ul id="autopilotApiKeyList" class="api-key-list"></ul>
              <p class="input-note" id="autopilotApiKeyListEmpty">No API keys saved yet.</p>
            </div>
          </div>

          <div class="autopilot-api-card" role="group" aria-labelledby="openrouterApiKeyHeading">
            <div class="autopilot-api-header">
              <div>
                <p class="eyebrow">AI access</p>
                <h3 id="openrouterApiKeyHeading" class="autopilot-api-title">OpenRouter API key</h3>
                <p class="autopilot-api-description">Used when the default provider is set to OpenRouter.</p>
              </div>
              <span class="status-pill offline" id="openrouterApiKeyStatus">No key saved</span>
            </div>
            <label for="openrouterApiKey">
              <div class="autopilot-api-row">
                <input
                  id="openrouterApiKey"
                  name="openrouter_api_key"
                  type="password"
                  inputmode="text"
                  autocomplete="off"
                  spellcheck="false"
                  placeholder="or-..."
                />
                <button type="button" id="clearOpenrouterApiKey" class="secondary">Remove key</button>
              </div>
            </label>
            <p class="input-note" id="openrouterApiKeyNote">
              Saved securely on the server for autopilot replies. Leave blank to keep your existing key or use the
              remove button above. The <code>OPENROUTER_API_KEY</code> environment variable will be used as a fallback.
            </p>
            <div class="saved-keys">
              <p class="eyebrow">Saved API keys</p>
              <ul id="openrouterApiKeyList" class="api-key-list"></ul>
              <p class="input-note" id="openrouterApiKeyListEmpty">No API keys saved yet.</p>
            </div>
          </div>
          <div class="form-feedback" id="autopilotFeedback"></div>
          <div class="panel-actions">
            <button type="submit" class="primary">Save autopilot settings</button>
          </div>
        </form>
      </div>
    </section>

    <section class="panel" aria-labelledby="weather-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="weather-heading">Weather overlay</h2>
          <p>Show a quick weather hint beside each public booking slot.</p>
        </div>
        <div class="panel-actions">
          <span class="status-pill offline" id="weatherStatus">No API key saved</span>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="weatherPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight">Add a weather API key to decorate time slots with sunshine, cloud or shower icons.</p>
        <p class="panel-summary-note">Slots use the Audenshaw / Denton, Manchester forecast for their date and hour.</p>
      </div>
      <div class="panel-body" id="weatherPanelBody" hidden>
        <form id="weatherForm" class="autopilot-controls">
          <div class="autopilot-api-card" role="group" aria-labelledby="weatherApiKeyHeading">
            <div class="autopilot-api-header">
              <div>
                <p class="eyebrow">Forecast access</p>
                <h3 id="weatherApiKeyHeading" class="autopilot-api-title">Weather API key</h3>
                <p class="autopilot-api-description">Stored securely and used to fetch the Audenshaw / Denton forecast.</p>
              </div>
            </div>
            <label for="weatherApiKey">
              <div class="autopilot-api-row">
                <input
                  id="weatherApiKey"
                  name="api_key"
                  type="password"
                  inputmode="text"
                  autocomplete="off"
                  spellcheck="false"
                  placeholder="Your weather provider API key"
                />
              </div>
            </label>
            <p class="input-note">
              Save a key from your weather provider (for example WeatherAPI.com). Leave the box untouched to keep the existing
              saved key, or clear it to remove the stored value. The optional <code>WEATHER_API_KEY</code> environment
              variable will be used if set.
            </p>
            <div class="saved-keys">
              <p class="eyebrow">Saved API keys</p>
              <ul id="weatherApiKeyList" class="api-key-list"></ul>
              <p class="input-note" id="weatherApiKeyListEmpty">No weather API keys saved yet.</p>
            </div>
          </div>
          <div class="form-feedback" id="weatherFeedback"></div>
          <div class="panel-actions">
            <button type="submit" class="primary">Save weather settings</button>
          </div>
        </form>
      </div>
    </section>

    <section class="panel" aria-labelledby="images-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="images-heading">Website images</h2>
          <p>View and replace images stored in <code>/static/images</code>.</p>
        </div>
        <div class="panel-actions">
          <button type="button" id="refreshImages" class="secondary">Refresh</button>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="imagesPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="imagesSummaryHighlight">Manage uploaded site images.</p>
        <p class="panel-summary-note">Replace a file to update it anywhere itâ€™s used on the site.</p>
      </div>
      <div class="panel-body" id="imagesPanelBody" hidden>
        <div class="image-library-toolbar">
          <p class="input-note" id="imagesHelpText">
            Tip: to update an existing image on the site, replace it using the same filename.
          </p>
          <div class="panel-actions">
            <input id="uploadNewImage" type="file" accept="image/*" />
            <button type="button" id="uploadNewImageBtn" class="primary">Upload new</button>
          </div>
        </div>
        <div class="form-feedback" id="imagesFeedback"></div>
        <div class="image-library-grid" id="imageLibraryGrid"></div>
      </div>
    </section>

    <section class="panel" aria-labelledby="telnyx-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="telnyx-heading">SMS Verification (Telnyx)</h2>
          <p>Use your Telnyx number to send verification codes to customers (preferred SMS provider).</p>
        </div>
        <div class="panel-actions">
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="telnyxPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="telnyxSummaryHighlight">Verify customer phone numbers via Telnyx SMS.</p>
        <p class="panel-summary-note">Expand to add your Telnyx API key and your Telnyx phone number.</p>
      </div>
      <div class="panel-body" id="telnyxPanelBody" hidden>
        <form id="telnyxForm" class="grid" autocomplete="off" novalidate>
          <div class="section">
            <div class="autopilot-api-header">
              <div>
                <p class="eyebrow">SMS Configuration</p>
                <h3 class="autopilot-api-title">Telnyx Setup</h3>
                <p class="autopilot-api-description">
                  Add your Telnyx <strong>API key</strong> and the <strong>Telnyx phone number</strong> you want to send from.
                  If Telnyx is configured, the website will use it to send verification codes.
                </p>
              </div>
            </div>

            <div style="background: rgba(48, 195, 166, 0.08); border: 1px solid rgba(48, 195, 166, 0.25); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
              <p style="margin: 0 0 12px 0; font-weight: 600; color: var(--accent);">ðŸ“± What you need from Telnyx:</p>
              <ol style="margin: 0; padding-left: 20px; line-height: 1.8;">
                <li>Create an API key in your Telnyx Mission Control Portal</li>
                <li>Make sure your Telnyx number can send SMS</li>
                <li>Enter the number in international format (E.164), e.g. <strong>+447123456789</strong></li>
              </ol>
            </div>

            <label for="telnyxApiKey">
              <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">
                1ï¸âƒ£ Telnyx API Key <span style="color: var(--danger);">*</span>
              </strong>
              <p style="font-size: 0.85rem; color: var(--text-muted); margin: 0 0 8px 0;">
                Stored securely and used to send verification SMS. Leave blank to keep the saved key.
              </p>
              <div class="autopilot-api-row">
                <input
                  id="telnyxApiKey"
                  name="api_key"
                  type="password"
                  autocomplete="off"
                  spellcheck="false"
                  placeholder="Enter your Telnyx API key"
                />
              </div>
            </label>

            <label for="telnyxFromNumber">
              <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">
                2ï¸âƒ£ From number (your Telnyx number) <span style="color: var(--danger);">*</span>
              </strong>
              <p style="font-size: 0.85rem; color: var(--text-muted); margin: 0 0 8px 0;">
                Must be your Telnyx phone number in E.164 format.
              </p>
              <div class="autopilot-api-row">
                <input
                  id="telnyxFromNumber"
                  name="from_number"
                  type="tel"
                  inputmode="tel"
                  autocomplete="off"
                  spellcheck="false"
                  placeholder="e.g. +447123456789"
                />
              </div>
            </label>

            <label for="telnyxMessagingProfileId">
              <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">
                3ï¸âƒ£ Messaging Profile ID <span style="font-size: 0.8rem; color: var(--text-muted);">(optional)</span>
              </strong>
              <p style="font-size: 0.85rem; color: var(--text-muted); margin: 0 0 8px 0;">
                Found in your Telnyx Mission Control &gt; Messaging &gt; Profiles. Leave blank if you have only one profile.
              </p>
              <div class="autopilot-api-row">
                <input
                  id="telnyxMessagingProfileId"
                  name="messaging_profile_id"
                  type="text"
                  autocomplete="off"
                  spellcheck="false"
                  placeholder="e.g. 40017e1c-â€¦"
                />
              </div>
            </label>

            <p class="input-note" id="telnyxStatus" style="font-weight: 600; font-size: 1rem; margin-top: 16px;"></p>

            <!-- Diagnostics panel -->
            <div id="telnyxDiagnosticsPanel" style="display:none; background: #1a1a2e; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 16px; margin-top: 16px;">
              <p style="margin: 0 0 12px 0; font-weight: 600; color: #fff;">ðŸ” Configuration Check</p>
              <div id="telnyxDiagnosticsList" style="font-family: monospace; font-size: 0.85rem; line-height: 1.8;"></div>
            </div>
          </div>
          <div class="form-feedback" id="telnyxFeedback"></div>
          <div class="panel-actions">
            <button type="submit" class="primary">Save Telnyx settings</button>
            <button type="button" class="primary" id="telnyxDiagnosticsBtn" style="background: #2a6; margin-left: 8px;" onclick="runTelnyxDiagnostics()">Check Config</button>
          </div>

          <!-- Test SMS section -->
          <div style="border-top: 1px solid rgba(255,255,255,0.1); margin-top: 24px; padding-top: 20px;">
            <p style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">ðŸ“² Send a Test SMS</p>
            <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 12px;">
              Enter your mobile number below and click "Send Test" to verify everything is working.
            </p>
            <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
              <input
                id="telnyxTestPhone"
                type="tel"
                inputmode="tel"
                placeholder="e.g. 07123456789"
                style="flex: 1; min-width: 180px;"
              />
              <button type="button" class="primary" id="telnyxTestBtn" style="background: #e67e22; white-space: nowrap;" onclick="sendTelnyxTest()">Send Test SMS</button>
            </div>
            <p id="telnyxTestResult" style="margin-top: 12px; font-weight: 600; font-size: 0.95rem;"></p>
          </div>
        </form>
      </div>
    </section>

    <section class="panel" aria-labelledby="smsapi-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="smsapi-heading">SMS Verification (SMSAPI.com)</h2>
          <p>Configure SMS verification for quote requests using SMSAPI.com (cheap, simple, zero compliance).</p>
        </div>
        <div class="panel-actions">
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="smsapiPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="smsapiSummaryHighlight">Verify customer phone numbers via SMS (~2-3p per message).</p>
        <p class="panel-summary-note">Expand to configure your SMSAPI.com credentials for sending verification codes.</p>
      </div>
      <div class="panel-body" id="smsapiPanelBody" hidden>
        <form id="smsapiForm" class="grid" autocomplete="off" novalidate>
          <div class="section">
            <div class="autopilot-api-header">
              <div>
                <p class="eyebrow">SMS Configuration</p>
                <h3 class="autopilot-api-title">SMSAPI.com Setup</h3>
                <p class="autopilot-api-description">
                  Configure your SMSAPI.com account to send verification codes to customers via SMS. 
                  <strong>OAuth token is required</strong> for SMS verification to work.
                </p>
              </div>
            </div>
            
            <div style="background: rgba(48, 195, 166, 0.08); border: 1px solid rgba(48, 195, 166, 0.25); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
              <p style="margin: 0 0 12px 0; font-weight: 600; color: var(--accent);">ðŸ“± How to get your SMSAPI.com credentials:</p>
              <ol style="margin: 0; padding-left: 20px; line-height: 1.8;">
                <li>Sign up at <a href="https://www.smsapi.com/" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: underline;">smsapi.com</a> (free trial credits included)</li>
                <li>Log in and go to <strong>Settings â†’ API Password</strong></li>
                <li>Generate an <strong>OAuth token</strong> (recommended) or use username/password auth</li>
                <li>Copy the token - it starts with a long random string</li>
              </ol>
            </div>

            <label for="smsapiOauthToken">
              <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">
                1ï¸âƒ£ OAuth Token <span style="color: var(--danger);">*</span>
              </strong>
              <p style="font-size: 0.85rem; color: var(--text-muted); margin: 0 0 8px 0;">
                Found in your SMSAPI dashboard under Settings â†’ API Password. A long secure token for authentication.
              </p>
              <div class="autopilot-api-row">
                <input
                  id="smsapiOauthToken"
                  name="oauth_token"
                  type="password"
                  autocomplete="off"
                  spellcheck="false"
                  placeholder="Enter your SMSAPI OAuth Token"
                  required
                />
              </div>
            </label>

            <label for="smsapiSenderName">
              <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">
                2ï¸âƒ£ Sender Name (optional)
              </strong>
              <p style="font-size: 0.85rem; color: var(--text-muted); margin: 0 0 8px 0;">
                This appears as the sender when customers receive the SMS. Can be your business name (e.g., "PayAsYouMow") or leave blank for default.
              </p>
              <div class="autopilot-api-row">
                <input
                  id="smsapiSenderName"
                  name="sender_name"
                  type="text"
                  autocomplete="off"
                  spellcheck="false"
                  placeholder="e.g., PayAsYouMow (11 chars max for alphanumeric)"
                />
              </div>
            </label>

            <div style="background: rgba(255, 215, 102, 0.08); border: 1px solid rgba(255, 215, 102, 0.25); border-radius: 12px; padding: 14px; margin-top: 16px;">
              <p style="margin: 0; font-size: 0.9rem; color: var(--text-muted);">
                <strong style="color: var(--warning);">ðŸ’¡ Note:</strong> Your OAuth token is stored securely and only used for sending verification codes. SMSAPI.com charges ~2-3p per UK SMS.
              </p>
            </div>

            <p class="input-note" id="smsapiStatus" style="font-weight: 600; font-size: 1rem; margin-top: 16px;"></p>
          </div>
          <div class="form-feedback" id="smsapiFeedback"></div>
          <div class="panel-actions">
            <button type="submit" class="primary">Save SMS settings</button>
          </div>
        </form>
      </div>
    </section>

    <section class="panel" aria-labelledby="email-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="email-heading">Email Verification (Magic Link)</h2>
          <p>Send a confirmation link by email (no SMS provider required).</p>
        </div>
        <div class="panel-actions">
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="emailPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="emailSummaryHighlight">Verify customers via a one-click email link.</p>
        <p class="panel-summary-note">Expand to set SMTP settings (Gmail works well with an app password).</p>
      </div>
      <div class="panel-body" id="emailPanelBody" hidden>
        <form id="emailConfigForm" class="grid" autocomplete="off" novalidate>
          <div class="section">
            <div class="autopilot-api-header">
              <div>
                <p class="eyebrow">SMTP Configuration</p>
                <h3 class="autopilot-api-title">Email setup (recommended: Gmail)</h3>
                <p class="autopilot-api-description">
                  The website sends customers a confirmation link when they request a quote.
                  For Gmail you must use an <strong>App Password</strong> (not your normal password).
                </p>
              </div>
            </div>

            <div style="background: rgba(48, 195, 166, 0.08); border: 1px solid rgba(48, 195, 166, 0.25); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
              <p style="margin: 0 0 12px 0; font-weight: 600; color: var(--accent);">âœ‰ï¸ Gmail settings (copy these):</p>
              <ul style="margin: 0; padding-left: 20px; line-height: 1.8;">
                <li><strong>Host:</strong> smtp.gmail.com</li>
                <li><strong>Port:</strong> 587</li>
                <li><strong>Security:</strong> STARTTLS (enabled)</li>
                <li><strong>Username:</strong> your full Gmail address</li>
                <li><strong>Password:</strong> Google App Password (16 characters)</li>
              </ul>
            </div>

            <label for="smtpHost">
              <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">SMTP Host</strong>
              <div class="autopilot-api-row">
                <input id="smtpHost" name="host" type="text" autocomplete="off" spellcheck="false" placeholder="smtp.gmail.com" />
              </div>
            </label>

            <div class="autopilot-provider-row">
              <label style="flex:1; min-width: 180px;" for="smtpPort">
                <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">SMTP Port</strong>
                <div class="autopilot-api-row">
                  <input id="smtpPort" name="port" type="number" min="1" max="65535" step="1" placeholder="587" />
                </div>
              </label>

              <label style="flex:1; min-width: 220px;" for="smtpUseStarttls">
                <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">Security</strong>
                <div class="autopilot-api-row" style="align-items:center;">
                  <input id="smtpUseStarttls" name="use_starttls" type="checkbox" checked style="width: 18px; height: 18px;" />
                  <span style="opacity: 0.9;">Use STARTTLS</span>
                </div>
              </label>
            </div>

            <label for="smtpUsername">
              <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">SMTP Username</strong>
              <div class="autopilot-api-row">
                <input id="smtpUsername" name="username" type="text" autocomplete="off" spellcheck="false" placeholder="andyfast20@gmail.com" />
              </div>
            </label>

            <label for="smtpPassword">
              <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">SMTP Password (App Password)</strong>
              <p style="font-size: 0.85rem; color: var(--text-muted); margin: 0 0 8px 0;">
                For Gmail: Google Account â†’ Security â†’ 2â€‘Step Verification â†’ App passwords â†’ create one for â€œMailâ€.
              </p>
              <div class="autopilot-api-row">
                <input id="smtpPassword" name="password" type="password" autocomplete="off" spellcheck="false" placeholder="Enter your app password" />
              </div>
            </label>

            <div class="autopilot-provider-row">
              <label style="flex:1; min-width: 260px;" for="smtpFromEmail">
                <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">From Email</strong>
                <div class="autopilot-api-row">
                  <input id="smtpFromEmail" name="from_email" type="email" autocomplete="off" spellcheck="false" placeholder="andyfast20@gmail.com" />
                </div>
              </label>
              <label style="flex:1; min-width: 220px;" for="smtpFromName">
                <strong style="display: block; margin-bottom: 8px; color: var(--text-primary);">From Name</strong>
                <div class="autopilot-api-row">
                  <input id="smtpFromName" name="from_name" type="text" autocomplete="off" spellcheck="false" placeholder="Pay As You Mow" />
                </div>
              </label>
            </div>

            <p class="input-note" id="emailStatus" style="font-weight: 600; font-size: 1rem; margin-top: 16px;"></p>
          </div>
          <div class="form-feedback" id="emailFeedback"></div>
          <div class="panel-actions">
            <button type="submit" class="primary">Save email settings</button>
          </div>
        </form>
      </div>
    </section>

    <section class="panel" aria-labelledby="availability-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="availability-heading">Availability slots</h2>
          <p>Add or remove booking slots that show on the website.</p>
        </div>
        <div class="panel-actions">
          <button id="refreshAvailability" type="button">Refresh</button>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="availabilityPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="availabilitySummaryHighlight">Publish bookable slots when you're free.</p>
        <p class="panel-summary-note">Expand to add new times or quickly remove ones that are no longer available.</p>
      </div>
      <div class="panel-body" id="availabilityPanelBody" hidden>
        <form id="availabilityForm" class="grid" autocomplete="off">
          <label>
            Date
            <input type="date" name="date" required />
          </label>
          <label>
            Time
            <input type="time" name="time" step="900" min="06:00" max="21:00" required />
          </label>
          <button type="submit" class="primary">Add slot</button>
        </form>
        <div class="quick-picks" aria-label="Quick availability shortcuts">
          <div class="quick-picks-group">
            <span class="quick-picks-label">Quick dates</span>
            <div class="quick-picks-buttons" id="quickDateShortcuts"></div>
          </div>
          <div class="quick-picks-group">
            <span class="quick-picks-label">Quick times</span>
            <div class="quick-picks-buttons" id="quickTimeShortcuts">
              <button type="button" data-quick-time="18:00">6:00 PM</button>
              <button type="button" data-quick-time="18:30">6:30 PM</button>
              <button type="button" data-quick-time="19:00">7:00 PM</button>
              <button type="button" data-quick-time="19:30">7:30 PM</button>
            </div>
          </div>
        </div>
        <div class="quick-action">
          <button type="button" id="autoNextWeekSlots" class="secondary">Add next week's evening trio</button>
          <p class="quick-action-note">
            Creates three 15-minute evening appointments next Monday and Wednesday between 6pm and 8pm.
          </p>
          <div id="autoScheduleFeedback" class="form-feedback" aria-live="polite"></div>
        </div>
        <div id="availabilityList" class="empty-state">Loading availabilityâ€¦</div>
      </div>
    </section>

    <section class="panel" aria-labelledby="customer-slots-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="customer-slots-heading">Existing customer bookings</h2>
          <p>Publish and confirm appointment times reserved for returning customers.</p>
        </div>
        <div class="panel-actions">
          <button id="refreshCustomerSlots" type="button">Refresh</button>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="customerSlotsPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="customerSlotsSummaryHighlight">Add slots for priority customers to claim.</p>
        <p class="panel-summary-note">Expand to update the login access code, add new customer-only times and confirm bookings.</p>
      </div>
      <div class="panel-body" id="customerSlotsPanelBody" hidden>
        <div class="customer-slots-grid">
          <div>
            <h3 class="panel-subheading">Customer access code</h3>
            <p class="panel-summary-note" style="margin-top: 0.2rem;">
              Share this password with existing customers so they can log in and reserve their slots.
            </p>
            <form id="customerAccessForm" class="customer-access-form" autocomplete="off">
              <label>
                Access code
                <input type="text" id="customerAccessCodeInput" name="access_code" minlength="4" required />
              </label>
              <button type="submit" class="primary">Save access code</button>
            </form>
            <div class="form-feedback" id="customerAccessFeedback" aria-live="polite"></div>
          </div>

          <div>
            <h3 class="panel-subheading">Add customer-only slot</h3>
            <p class="panel-summary-note" style="margin-top: 0.2rem;">Customer slots cannot overlap with quote bookings or other customer slots.</p>
            <form id="customerSlotForm" class="grid" autocomplete="off">
              <label>
                Date
                <input type="date" name="date" required />
              </label>
              <label>
                Time
                <select name="time" required>
                  <option value="">Select a time</option>
                  <option value="09:00">9:00 AM</option>
                  <option value="11:00">11:00 AM</option>
                  <option value="13:00">1:00 PM</option>
                  <option value="15:00">3:00 PM</option>
                  <option value="17:00">5:00 PM</option>
                </select>
              </label>
              <button type="submit" class="primary">Add customer slot</button>
            </form>
            <div class="form-feedback" id="customerSlotFeedback" aria-live="polite"></div>
          </div>
        </div>

        <div class="customer-slot-list" id="customerSlotsList" aria-live="polite">Loading customer slotsâ€¦</div>
      </div>
    </section>

    <section class="panel" aria-labelledby="enquiries-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="enquiries-heading">Contact enquiries</h2>
          <p>Messages sent from the contact form instead of email.</p>
        </div>
        <div class="panel-actions">
          <button id="refreshContacts" type="button">Refresh</button>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="contactsPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="contactsSummaryHighlight">Keep enquiries organised in one place.</p>
        <p class="panel-summary-note">Expand to read messages, update their status or delete spam in seconds.</p>
      </div>
      <div class="panel-body" id="contactsPanelBody" hidden>
        <div id="contactsTable" class="empty-state">Waiting for enquiriesâ€¦</div>
      </div>
    </section>

    <section class="panel" aria-labelledby="reviews-heading" data-panel data-expanded="false">
      <div class="panel-header">
        <div class="meta">
          <h2 id="reviews-heading">Customer testimonials</h2>
          <p>Keep the homepage testimonials fresh and relevant.</p>
        </div>
        <div class="panel-actions">
          <button id="addReview" type="button" class="primary">Add testimonial</button>
          <button id="refreshReviews" type="button">Refresh</button>
          <button type="button" class="panel-toggle" aria-expanded="false" aria-controls="reviewsPanelBody">Expand</button>
        </div>
      </div>
      <div class="panel-summary">
        <p class="panel-summary-highlight" id="reviewsSummaryHighlight">Share success stories from your happiest clients.</p>
        <p class="panel-summary-note">Expand to add, edit or remove reviews that appear on the website.</p>
      </div>
      <div class="panel-body" id="reviewsPanelBody" hidden>
        <div id="reviewsTable" class="empty-state">Loading testimonialsâ€¦</div>
      </div>
    </section>
  </main>

  <dialog id="bookingDialog" aria-labelledby="bookingDialogTitle">
    <form id="bookingEditForm" method="dialog">
      <h3 id="bookingDialogTitle">Edit booking</h3>
      <p class="cell-muted" id="bookingDialogSubtitle">Update customer details and appointment slot.</p>
      <div class="form-feedback" id="bookingFormFeedback"></div>
      <div class="grid" style="margin-top: 1.25rem;">
        <label>
          Name
          <input type="text" id="bookingName" name="name" required />
        </label>
        <label>
          Email
          <input type="email" id="bookingEmail" name="email" required />
        </label>
        <label>
          Phone
          <input type="tel" id="bookingPhone" name="phone" required />
        </label>
        <label>
          Location
          <select id="bookingLocation" name="location">
            <option value="">Select areaâ€¦</option>
            <option value="Audenshaw">Audenshaw</option>
            <option value="Denton">Denton</option>
            <option value="Dukinfield">Dukinfield</option>
          </select>
        </label>
        <label style="grid-column: 1 / -1;">
          Appointment slot
          <input type="text" id="bookingTime" name="time" required />
        </label>
      </div>
      <div class="dialog-actions">
        <button type="button" id="closeBookingDialog">Cancel</button>
        <div class="right">
          <button type="submit" class="primary">Save changes</button>
        </div>
      </div>
    </form>
  </dialog>

  <dialog id="contactDialog" aria-labelledby="contactDialogTitle">
    <div>
      <h3 id="contactDialogTitle">Enquiry details</h3>
      <p class="cell-muted" id="contactDialogMeta"></p>
      <p id="contactDialogMessage" style="white-space: pre-line; margin-top: 1.2rem;"></p>
      <div class="form-feedback" id="contactDialogFeedback"></div>
      <div class="dialog-actions">
        <button type="button" id="closeContactDialog">Close</button>
        <div class="right">
          <button type="button" id="toggleContactStatus" class="primary"></button>
          <button type="button" id="deleteContact" class="danger">Delete</button>
        </div>
      </div>
    </div>
  </dialog>

  <dialog id="reviewDialog" aria-labelledby="reviewDialogTitle">
    <form id="reviewForm" method="dialog">
      <h3 id="reviewDialogTitle">Add testimonial</h3>
      <p class="cell-muted" id="reviewDialogSubtitle">Publish new words from your customers on the homepage.</p>
      <div class="form-feedback" id="reviewFormFeedback"></div>
      <div class="grid" style="margin-top: 1.25rem;">
        <label>
          Customer name
          <input type="text" id="reviewAuthor" name="author" placeholder="e.g. Emma Davis" required />
        </label>
        <label>
          Location (optional)
          <input type="text" id="reviewLocation" name="location" placeholder="e.g. Riverside" />
        </label>
      </div>
      <label style="margin-top: 1rem; display: block;">
        Testimonial
        <textarea id="reviewText" name="quote" rows="4" maxlength="600" placeholder="Write the customer's feedback in their own words." required></textarea>
      </label>
      <input type="hidden" id="reviewId" name="id" />
      <div class="dialog-actions">
        <button type="button" id="closeReviewDialog" class="secondary">Cancel</button>
        <div class="right">
          <button type="submit" class="primary">Save testimonial</button>
        </div>
      </div>
    </form>
  </dialog>

  <script>
    const bookingsTable = document.getElementById('bookingsTable');
    const onlineVisitorsContainer = document.getElementById('onlineVisitors');
    const visitorHistoryContainer = document.getElementById('visitorHistory');
    const availabilityList = document.getElementById('availabilityList');
    const customerSlotsList = document.getElementById('customerSlotsList');
    const contactsTable = document.getElementById('contactsTable');
    const reviewsTable = document.getElementById('reviewsTable');

    const bookingsSummaryHighlight = document.getElementById('bookingsSummaryHighlight');
    const presenceSummaryHighlight = document.getElementById('presenceSummaryHighlight');
    const chatSummaryHighlight = document.getElementById('chatSummaryHighlight');
    const autopilotSummaryHighlight = document.getElementById('autopilotSummaryHighlight');
    const availabilitySummaryHighlight = document.getElementById('availabilitySummaryHighlight');
    const customerSlotsSummaryHighlight = document.getElementById('customerSlotsSummaryHighlight');
    const contactsSummaryHighlight = document.getElementById('contactsSummaryHighlight');
    const reviewsSummaryHighlight = document.getElementById('reviewsSummaryHighlight');

    const panelToggles = Array.from(document.querySelectorAll('.panel-toggle'));
    const panels = Array.from(document.querySelectorAll('[data-panel]'));
    const panelGrid = document.querySelector('main.panel-grid');

    const availabilityForm = document.getElementById('availabilityForm');
    const availabilityDateInput = availabilityForm ? availabilityForm.querySelector('input[name="date"]') : null;
    const availabilityTimeInput = availabilityForm ? availabilityForm.querySelector('[name="time"]') : null;
    const quickDateShortcuts = document.getElementById('quickDateShortcuts');
    const quickTimeShortcuts = document.getElementById('quickTimeShortcuts');
    const autoNextWeekSlotsBtn = document.getElementById('autoNextWeekSlots');
    const autoScheduleFeedback = document.getElementById('autoScheduleFeedback');
    const customerSlotForm = document.getElementById('customerSlotForm');
    const customerSlotFeedback = document.getElementById('customerSlotFeedback');
    const customerAccessForm = document.getElementById('customerAccessForm');
    const customerAccessFeedback = document.getElementById('customerAccessFeedback');
    const customerAccessCodeInput = document.getElementById('customerAccessCodeInput');
    const refreshCustomerSlotsBtn = document.getElementById('refreshCustomerSlots');
    const refreshPresenceBtn = document.getElementById('refreshPresence');
    const refreshAvailabilityBtn = document.getElementById('refreshAvailability');
    const refreshBookingsBtn = document.getElementById('refreshBookings');
    const refreshContactsBtn = document.getElementById('refreshContacts');
    const refreshReviewsBtn = document.getElementById('refreshReviews');
    const addReviewBtn = document.getElementById('addReview');

    const chatStatusIndicator = document.getElementById('chatStatusIndicator');
    const chatWaitingAlert = document.getElementById('chatWaitingAlert');
    const toggleChatStatusBtn = document.getElementById('toggleChatStatus');
    const refreshChatSessionsBtn = document.getElementById('refreshChatSessions');
    const chatSessionsContainer = document.getElementById('chatSessionsContainer');
    const chatThread = document.getElementById('chatThread');
    const chatThreadEmpty = document.getElementById('chatThreadEmpty');
    const chatThreadTitle = document.getElementById('chatThreadTitle');
    const chatThreadMeta = document.getElementById('chatThreadMeta');
    const chatThreadMessages = document.getElementById('chatThreadMessages');
    const chatReplyForm = document.getElementById('chatReplyForm');
    const chatReplyInput = document.getElementById('chatReplyInput');
    const chatReplyStatus = document.getElementById('chatReplyStatus');
    const chatReplySubmit = chatReplyForm ? chatReplyForm.querySelector('button[type="submit"]') : null;

    const autopilotStatusBadge = document.getElementById('autopilotStatusBadge');
    const autopilotToggleButtons = [
      document.getElementById('autopilotToggle'),
      document.getElementById('autopilotToggleSecondary'),
    ].filter((button) => button instanceof HTMLButtonElement);
    const autopilotForm = document.getElementById('autopilotForm');
    const autopilotPromptInput = document.getElementById('autopilotPrompt');
    const autopilotFeedback = document.getElementById('autopilotFeedback');
    const autopilotSaveButton = autopilotForm ? autopilotForm.querySelector('button[type="submit"]') : null;
    const autopilotProviderSelect = document.getElementById('autopilotProvider');
    const autopilotApiKeyInput = document.getElementById('autopilotApiKey');
    const clearAutopilotApiKeyBtn = document.getElementById('clearAutopilotApiKey');
    const autopilotApiKeyNote = document.getElementById('autopilotApiKeyNote');
    const autopilotApiKeyStatus = document.getElementById('autopilotApiKeyStatus');
    const autopilotApiKeyList = document.getElementById('autopilotApiKeyList');
    const autopilotApiKeyListEmpty = document.getElementById('autopilotApiKeyListEmpty');
    const openrouterApiKeyInput = document.getElementById('openrouterApiKey');
    const clearOpenrouterApiKeyBtn = document.getElementById('clearOpenrouterApiKey');
    const openrouterApiKeyNote = document.getElementById('openrouterApiKeyNote');
    const openrouterApiKeyStatus = document.getElementById('openrouterApiKeyStatus');
    const openrouterApiKeyList = document.getElementById('openrouterApiKeyList');
    const openrouterApiKeyListEmpty = document.getElementById('openrouterApiKeyListEmpty');
    const autopilotWebsiteUrlInput = document.getElementById('autopilotWebsiteUrl');
    const autopilotWebsiteScrapeBtn = document.getElementById('autopilotWebsiteScrape');
    const autopilotWebsiteClearBtn = document.getElementById('autopilotWebsiteClear');
    const autopilotWebsiteStatus = document.getElementById('autopilotWebsiteStatus');
    const autopilotWebsiteNote = document.getElementById('autopilotWebsiteNote');
    const autopilotWebsiteMeta = document.getElementById('autopilotWebsiteMeta');
    const autopilotWebsitePreview = document.getElementById('autopilotWebsitePreview');
    const weatherStatus = document.getElementById('weatherStatus');
    const weatherForm = document.getElementById('weatherForm');
    const weatherApiKeyInput = document.getElementById('weatherApiKey');
    const weatherFeedback = document.getElementById('weatherFeedback');
    const weatherApiKeyList = document.getElementById('weatherApiKeyList');
    const weatherApiKeyListEmpty = document.getElementById('weatherApiKeyListEmpty');

    const refreshImagesBtn = document.getElementById('refreshImages');
    const imagesSummaryHighlight = document.getElementById('imagesSummaryHighlight');
    const imagesFeedback = document.getElementById('imagesFeedback');
    const imageLibraryGrid = document.getElementById('imageLibraryGrid');
    const uploadNewImageInput = document.getElementById('uploadNewImage');
    const uploadNewImageBtn = document.getElementById('uploadNewImageBtn');

    const CHAT_POLL_INTERVAL = 4000;
    const DEFAULT_CHAT_INVITE_MESSAGE = 'Hi there! We\'re online if you need a hand with anything.';
    let chatSessionsCache = [];
    let selectedChatSessionId = null;
    let chatMessagePollHandle = null;
    let chatLastMessageId = 0;
    let chatOnline = true;
    let chatSessionsLoading = null;
    let previousChatUnreadTotal = 0;
    let chatAttentionInitialised = false;
    let onlineVisitorsCache = [];
    let visitorHistoryCache = [];
    let availabilityCache = [];
    let customerSlotsCache = [];
    let customerAccessCodeValue = '';
    let bannedIpCache = new Map();
    const AUTOPILOT_DEFAULTS = {
      enabled: false,
      business_profile: '',
      business_website_url: '',
      business_website_last_scraped: '',
      has_business_website_knowledge: false,
      business_website_knowledge_chars: 0,
      business_website_knowledge_preview: '',
      provider: 'deepseek',
      model: 'deepseek-chat',
      temperature: 0.3,
      has_api_key: false,
      api_keys: [],
      has_openrouter_api_key: false,
      openrouter_api_keys: [],
    };
    const WEATHER_DEFAULTS = { has_api_key: false, api_keys: [] };
    let autopilotConfig = { ...AUTOPILOT_DEFAULTS };
    let weatherConfig = { ...WEATHER_DEFAULTS };
    let autopilotBusy = false;

    const bookingDialog = document.getElementById('bookingDialog');
    const bookingEditForm = document.getElementById('bookingEditForm');
    const bookingFormFeedback = document.getElementById('bookingFormFeedback');
    const bookingNameInput = document.getElementById('bookingName');
    const bookingEmailInput = document.getElementById('bookingEmail');
    const bookingPhoneInput = document.getElementById('bookingPhone');
    const bookingLocationInput = document.getElementById('bookingLocation');
    const bookingTimeInput = document.getElementById('bookingTime');
    const closeBookingDialogBtn = document.getElementById('closeBookingDialog');

    const contactDialog = document.getElementById('contactDialog');
    const contactDialogMeta = document.getElementById('contactDialogMeta');
    const contactDialogMessage = document.getElementById('contactDialogMessage');
    const contactDialogFeedback = document.getElementById('contactDialogFeedback');
    const toggleContactStatusBtn = document.getElementById('toggleContactStatus');
    const deleteContactBtn = document.getElementById('deleteContact');
    const closeContactDialogBtn = document.getElementById('closeContactDialog');

    const reviewDialog = document.getElementById('reviewDialog');
    const reviewForm = document.getElementById('reviewForm');
    const reviewFormFeedback = document.getElementById('reviewFormFeedback');
    const reviewDialogTitle = document.getElementById('reviewDialogTitle');
    const reviewDialogSubtitle = document.getElementById('reviewDialogSubtitle');
    const reviewAuthorInput = document.getElementById('reviewAuthor');
    const reviewLocationInput = document.getElementById('reviewLocation');
    const reviewTextInput = document.getElementById('reviewText');
    const reviewIdInput = document.getElementById('reviewId');
    const closeReviewDialogBtn = document.getElementById('closeReviewDialog');
    const reviewSubmitButton = reviewForm ? reviewForm.querySelector('button[type="submit"]') : null;

    let bookingsCache = [];
    let contactsCache = [];
    let reviewsCache = [];
    let previousVisitorIps = new Set();
    let onlinePresenceInitialised = false;
    let audioContextInstance = null;

    const supportsDialog = typeof HTMLDialogElement === 'function';

    function showDialog(dialog) {
      if (supportsDialog && typeof dialog.showModal === 'function') {
        dialog.showModal();
      } else {
        dialog.setAttribute('open', '');
      }
    }

    function closeDialog(dialog) {
      if (supportsDialog && typeof dialog.close === 'function') {
        dialog.close();
      } else {
        dialog.removeAttribute('open');
      }
    }

    function escapeHtml(str) {
      if (typeof str !== 'string') return '';
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function formatDate(value) {
      if (!value) return 'â€”';
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) {
        return value;
      }
      return date.toLocaleString();
    }

    function formatTime(value) {
      if (!value) return 'â€”';
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) {
        return value;
      }
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function formatDuration(value) {
      const seconds = Number(value);
      if (!Number.isFinite(seconds) || seconds <= 0) {
        return '0s';
      }
      const totalSeconds = Math.floor(seconds);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const secs = totalSeconds % 60;
      const parts = [];
      if (hours > 0) {
        parts.push(`${hours}h`);
      }
      if (minutes > 0) {
        parts.push(`${minutes}m`);
      }
      if (secs > 0 || parts.length === 0) {
        parts.push(`${secs}s`);
      }
      return parts.join(' ');
    }

    function toDateInputValue(date) {
      if (!(date instanceof Date)) return '';
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function formatQuickDateLabel(date) {
      if (!(date instanceof Date)) return '';
      return new Intl.DateTimeFormat(undefined, {
        weekday: 'short',
        day: 'numeric',
        month: 'short',
      }).format(date);
    }

    function markActiveQuickButtons(container, dataAttribute, value) {
      if (!container) return;
      container.querySelectorAll('button').forEach((button) => {
        if (button.dataset[dataAttribute] === value) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      });
    }

    function renderQuickDateButtons() {
      if (!quickDateShortcuts || !availabilityDateInput) return;
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      quickDateShortcuts.innerHTML = '';
      for (let offset = 0; offset < 7; offset += 1) {
        const optionDate = new Date(today);
        optionDate.setDate(today.getDate() + offset);
        const value = toDateInputValue(optionDate);
        const label = formatQuickDateLabel(optionDate);
        const button = document.createElement('button');
        button.type = 'button';
        button.dataset.date = value;
        button.textContent = label;
        button.addEventListener('click', () => {
          availabilityDateInput.value = value;
          availabilityDateInput.dispatchEvent(new Event('input', { bubbles: true }));
          markActiveQuickButtons(quickDateShortcuts, 'date', value);
        });
        quickDateShortcuts.appendChild(button);
      }
      markActiveQuickButtons(quickDateShortcuts, 'date', availabilityDateInput.value);
    }

    function updateQuickTimeButtons(value) {
      if (!quickTimeShortcuts) return;
      quickTimeShortcuts.querySelectorAll('button').forEach((button) => {
        if (button.dataset.quickTime === value) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      });
    }

    function updateAutoScheduleFeedback(message, success = false) {
      if (!autoScheduleFeedback) return;
      autoScheduleFeedback.textContent = message;
      autoScheduleFeedback.classList.add('visible');
      if (success) {
        autoScheduleFeedback.classList.add('success');
      } else {
        autoScheduleFeedback.classList.remove('success');
      }
    }

    function clearAutoScheduleFeedback() {
      if (!autoScheduleFeedback) return;
      autoScheduleFeedback.textContent = '';
      autoScheduleFeedback.classList.remove('visible');
      autoScheduleFeedback.classList.remove('success');
    }

    function computeNextWeekEveningSlots() {
      const base = new Date();
      base.setHours(0, 0, 0, 0);
      const day = base.getDay();
      let daysUntilNextMonday = (8 - day) % 7;
      if (daysUntilNextMonday === 0) {
        daysUntilNextMonday = 7;
      }
      const monday = new Date(base);
      monday.setDate(base.getDate() + daysUntilNextMonday);
      const wednesday = new Date(monday);
      wednesday.setDate(monday.getDate() + 2);

      const schedule = [
        { date: monday, times: ['18:00', '18:30'] },
        { date: wednesday, times: ['18:00'] },
      ];

      return schedule
        .flatMap((entry) =>
          entry.times.map((time) => ({
            date: toDateInputValue(entry.date),
            time,
          }))
        )
        .slice(0, 3);
    }

    function formatSlotDescription(dateStr, timeStr) {
      if (!dateStr || !timeStr) {
        return `${dateStr || ''} ${timeStr || ''}`.trim();
      }
      try {
        const [year, month, day] = dateStr.split('-').map(Number);
        const [hours, minutes] = timeStr.split(':').map(Number);
        const slotDate = new Date(year, month - 1, day, hours, minutes);
        const dateFormatter = new Intl.DateTimeFormat(undefined, {
          weekday: 'short',
          day: 'numeric',
          month: 'short',
        });
        const timeFormatter = new Intl.DateTimeFormat(undefined, {
          hour: 'numeric',
          minute: '2-digit',
        });
        return `${dateFormatter.format(slotDate)} at ${timeFormatter.format(slotDate)}`;
      } catch (error) {
        return `${dateStr} ${timeStr}`.trim();
      }
    }

    async function createAvailabilitySlot(date, time) {
      const params = new URLSearchParams();
      params.set('date', date);
      params.set('time', time);
      const res = await fetch('/bookings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: params.toString(),
      });
      if (!res.ok) {
        throw new Error('Unable to add slot. Please try again.');
      }
    }

    function renderCustomerSlots(slots = []) {
      if (!customerSlotsList || !customerSlotsSummaryHighlight) return;
      customerSlotsCache = Array.isArray(slots) ? slots : [];

      if (!slots.length) {
        customerSlotsList.className = 'empty-state';
        customerSlotsList.textContent = 'No customer slots added yet.';
        setSummaryText(customerSlotsSummaryHighlight, 'Add slots for returning customers.');
        return;
      }

      const booked = slots.filter((slot) => slot.status === 'booked').length;
      const confirmed = slots.filter((slot) => slot.status === 'confirmed').length;
      const available = slots.filter((slot) => slot.status === 'available').length;
      setSummaryText(
        customerSlotsSummaryHighlight,
        `${available} available Â· ${booked} booked Â· ${confirmed} confirmed`
      );

      customerSlotsList.className = 'customer-slot-list';
      customerSlotsList.innerHTML = slots
        .map((slot) => {
          const status = (slot.status || 'available').toLowerCase();
          const name = escapeHtml(slot.customer_name || '');
          const phone = escapeHtml(slot.customer_phone || '');
          const label = escapeHtml(slot.label || `${slot.date || ''} ${slot.time || ''}`.trim());
          const badgeClass = status === 'confirmed' ? 'badge done' : status === 'booked' ? 'badge new' : 'badge';
          const badgeLabel = status === 'confirmed' ? 'Confirmed' : status === 'booked' ? 'Booked' : 'Available';

          return `
            <div class="customer-slot-row">
              <div class="customer-slot-meta">
                <div>
                  <strong>${label}</strong>
                  <span class="badge ${badgeClass}">${badgeLabel}</span>
                </div>
                ${name || phone ? `<p class="customer-slot-detail">${[name, phone].filter(Boolean).join(' Â· ')}</p>` : ''}
              </div>
              <div class="customer-slot-actions" data-slot-id="${slot.id}">
                ${
                  status === 'available'
                    ? '<button type="button" data-status="booked">Reserve</button>'
                    : ''
                }
                ${
                  status === 'booked'
                    ? '<button type="button" data-status="confirmed">Confirm</button>'
                    : ''
                }
                ${
                  status !== 'available'
                    ? '<button type="button" data-status="available" class="secondary">Release</button>'
                    : ''
                }
                <button type="button" class="danger" data-delete="true">Delete</button>
              </div>
            </div>
          `;
        })
        .join('');

      customerSlotsList.querySelectorAll('[data-slot-id]').forEach((row) => {
        const slotId = row.getAttribute('data-slot-id') || '';
        row.querySelectorAll('button[data-status]').forEach((button) => {
          button.addEventListener('click', () => updateCustomerSlotStatus(slotId, button.dataset.status));
        });
        const deleteBtn = row.querySelector('button[data-delete]');
        if (deleteBtn) {
          deleteBtn.addEventListener('click', () => deleteCustomerSlot(slotId));
        }
      });
    }

    async function loadCustomerSlots() {
      if (!customerSlotsList) return;
      customerSlotsList.className = 'empty-state';
      customerSlotsList.textContent = 'Loading customer slotsâ€¦';
      setSummaryText(customerSlotsSummaryHighlight, 'Loading customer appointmentsâ€¦');
      try {
        const res = await fetch('/api/customer/slots');
        if (!res.ok) throw new Error('Unable to load customer slots');
        const data = await res.json();
        renderCustomerSlots(Array.isArray(data.slots) ? data.slots : []);
      } catch (error) {
        customerSlotsList.className = 'empty-state';
        customerSlotsList.textContent = error.message || 'Unable to load customer slots.';
        setSummaryText(customerSlotsSummaryHighlight, error.message || 'Customer slots unavailable.');
      }
    }

    async function updateCustomerSlotStatus(slotId, status) {
      if (!slotId || !status) return;
      try {
        const res = await fetch(`/api/customer/slots/${encodeURIComponent(slotId)}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to update slot');
        }
        await loadCustomerSlots();
      } catch (error) {
        alert(error.message || 'Unable to update slot right now.');
      }
    }

    async function deleteCustomerSlot(slotId) {
      if (!slotId) return;
      const confirmed = window.confirm('Delete this customer slot?');
      if (!confirmed) return;
      try {
        const res = await fetch(`/api/customer/slots/${encodeURIComponent(slotId)}`, { method: 'DELETE' });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to delete slot');
        }
        await loadCustomerSlots();
      } catch (error) {
        alert(error.message || 'Unable to delete slot right now.');
      }
    }

    async function addCustomerSlot(date, time) {
      const res = await fetch('/api/customer/slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ date, time }),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        throw new Error(data.message || 'Unable to add customer slot');
      }
      return data;
    }

    async function loadCustomerAccessCode() {
      if (!customerAccessCodeInput) return;
      customerAccessFeedback?.classList.remove('visible', 'error', 'success');
      try {
        const res = await fetch('/api/customer/settings');
        if (!res.ok) throw new Error('Unable to load access code');
        const data = await res.json();
        customerAccessCodeValue = data.access_code || '';
        customerAccessCodeInput.value = customerAccessCodeValue;
        setSummaryText(customerSlotsSummaryHighlight, 'Access code ready to share with customers.');
      } catch (error) {
        customerAccessCodeValue = '';
        setSummaryText(customerSlotsSummaryHighlight, error.message || 'Access code unavailable.');
      }
    }

    async function saveCustomerAccessCode(accessCode) {
      const res = await fetch('/api/customer/settings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ access_code: accessCode }),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        throw new Error(data.message || 'Unable to save access code');
      }
      customerAccessCodeValue = accessCode;
      return data;
    }

    function setBannedIpCache(list) {
      const map = new Map();
      if (Array.isArray(list)) {
        list.forEach((entry) => {
          if (!entry || typeof entry !== 'object') return;
          const ip = typeof entry.ip === 'string' ? entry.ip.trim() : '';
          if (!ip) return;
          map.set(ip, {
            ip,
            banned_at: typeof entry.banned_at === 'string' ? entry.banned_at : '',
            reason: typeof entry.reason === 'string' ? entry.reason : '',
          });
        });
      }
      bannedIpCache = map;
    }

    function getBannedEntry(ip) {
      if (!ip || !(bannedIpCache instanceof Map)) {
        return null;
      }
      return bannedIpCache.get(ip) || null;
    }

    function setSummaryText(element, text) {
      if (element) {
        element.textContent = text;
      }
    }

    function updateBookingSummary() {
      if (!bookingsSummaryHighlight) return;
      if (!bookingsCache.length) {
        setSummaryText(bookingsSummaryHighlight, 'No confirmed bookings yet.');
        return;
      }

      const total = bookingsCache.length;
      const nextBooking = bookingsCache[0] || {};
      const name = typeof nextBooking.name === 'string' && nextBooking.name.trim()
        ? nextBooking.name.trim()
        : 'Upcoming visit';
      const time = typeof nextBooking.time === 'string' && nextBooking.time.trim()
        ? nextBooking.time.trim()
        : '';
      const location = typeof nextBooking.location === 'string' && nextBooking.location.trim()
        ? nextBooking.location.trim()
        : '';
      const details = [time, location].filter(Boolean).join(' â€¢ ');
      const detailText = details ? ` (${details})` : '';
      setSummaryText(
        bookingsSummaryHighlight,
        `${total} ${total === 1 ? 'booking' : 'bookings'} scheduled. Next: ${name}${detailText}.`
      );
    }

    function updatePresenceSummary(visitors = []) {
      if (!presenceSummaryHighlight) return;
      const list = Array.isArray(visitors) ? visitors : [];
      const savedCount = Array.isArray(visitorHistoryCache) ? visitorHistoryCache.length : 0;
      const bannedCount = bannedIpCache instanceof Map ? bannedIpCache.size : 0;
      if (!list.length) {
        const fragments = [];
        if (savedCount > 0) {
          const label = savedCount === 1 ? 'homepage visit saved' : 'homepage visits saved';
          fragments.push(`${savedCount} ${label}`);
        }
        if (bannedCount > 0) {
          const bannedLabel = bannedCount === 1 ? 'IP banned' : 'IPs banned';
          fragments.push(`${bannedCount} ${bannedLabel}`);
        }
        const suffix = fragments.length ? ` ${fragments.join(' â€¢ ')}` : '';
        setSummaryText(presenceSummaryHighlight, `No active visitors right now.${suffix}`);
        return;
      }

      const locations = new Set(
        list
          .map((visitor) => (visitor && typeof visitor.location === 'string' ? visitor.location.trim() : ''))
          .filter(Boolean)
      );
      const locationSuffix = locations.size
        ? ` from ${locations.size} location${locations.size === 1 ? '' : 's'}`
        : '';
      const savedSuffix = savedCount
        ? ` â€¢ ${savedCount} ${savedCount === 1 ? 'homepage visit saved' : 'homepage visits saved'}`
        : '';
      const bannedSuffix = bannedCount
        ? ` â€¢ ${bannedCount} ${bannedCount === 1 ? 'IP banned' : 'IPs banned'}`
        : '';
      setSummaryText(
        presenceSummaryHighlight,
        `${list.length} active ${list.length === 1 ? 'visitor' : 'visitors'} browsing${locationSuffix}.${savedSuffix}${bannedSuffix}`
      );
    }

    function updateAvailabilitySummary(slots = []) {
      if (!availabilitySummaryHighlight) return;
      const list = Array.isArray(slots) ? slots : [];
      if (!list.length) {
        setSummaryText(availabilitySummaryHighlight, 'No free slots published right now.');
        return;
      }

      const nextSlot = list[0] || '';
      const suffix = nextSlot ? ` â€¢ next ${nextSlot}` : '';
      setSummaryText(
        availabilitySummaryHighlight,
        `${list.length} available ${list.length === 1 ? 'slot' : 'slots'} live on the site${suffix}.`
      );
    }

    function updateChatAttentionIndicator(unreadTotal = 0) {
      if (!chatWaitingAlert) {
        previousChatUnreadTotal = Number(unreadTotal) || 0;
        chatAttentionInitialised = true;
        return;
      }

      const count = Number(unreadTotal) || 0;
      if (count > 0) {
        const label = count === 1 ? 'Visitor waiting to chat' : `${count} visitors waiting to chat`;
        chatWaitingAlert.textContent = label;
        chatWaitingAlert.classList.add('visible');
        chatWaitingAlert.setAttribute('aria-hidden', 'false');
        if (chatAttentionInitialised && count > previousChatUnreadTotal) {
          beepOnce();
        }
      } else {
        chatWaitingAlert.classList.remove('visible');
        chatWaitingAlert.setAttribute('aria-hidden', 'true');
        chatWaitingAlert.textContent = 'Visitor waiting to chat';
      }

      previousChatUnreadTotal = count;
      chatAttentionInitialised = true;
    }

    function updateContactSummary() {
      if (!contactsSummaryHighlight) return;
      if (!contactsCache.length) {
        setSummaryText(contactsSummaryHighlight, 'No enquiries yet.');
        return;
      }

      const newCount = contactsCache.filter((contact) => contact && contact.status === 'new').length;
      const suffix = newCount ? ` â€¢ ${newCount} new` : '';
      setSummaryText(
        contactsSummaryHighlight,
        `${contactsCache.length} contact ${contactsCache.length === 1 ? 'enquiry' : 'enquiries'}${suffix}.`
      );
    }

    function updateReviewsSummary() {
      if (!reviewsSummaryHighlight) return;
      if (!reviewsCache.length) {
        setSummaryText(reviewsSummaryHighlight, 'No testimonials published yet.');
        return;
      }

      const count = reviewsCache.length;
      const highlight = `${count} customer ${count === 1 ? 'testimonial' : 'testimonials'} live on your homepage.`;
      setSummaryText(reviewsSummaryHighlight, highlight);
    }

    function formatBytes(bytes) {
      const value = Number(bytes);
      if (!Number.isFinite(value) || value <= 0) return '0 B';
      const units = ['B', 'KB', 'MB', 'GB'];
      let idx = 0;
      let num = value;
      while (num >= 1024 && idx < units.length - 1) {
        num /= 1024;
        idx += 1;
      }
      return `${num.toFixed(idx === 0 ? 0 : 1)} ${units[idx]}`;
    }

    function showImagesFeedback(message, isSuccess = false) {
      if (!imagesFeedback) return;
      imagesFeedback.textContent = message || '';
      imagesFeedback.classList.toggle('visible', Boolean(message));
      imagesFeedback.classList.toggle('success', Boolean(message) && Boolean(isSuccess));
    }

    function setImagesSummary(text) {
      if (!imagesSummaryHighlight) return;
      setSummaryText(imagesSummaryHighlight, text);
    }

    const IMAGE_USAGE_LABELS = {
      'images/hero-mowing.svg': 'Homepage â†’ Hero background (slide 1)\nTip: great place for a wide â€œbefore/afterâ€ or mowing photo.',
      'images/hero-weeding.svg': 'Homepage â†’ Hero background (slide 2)\nTip: great place for a wide garden/flowerbed photo.',
      'images/offer-gardener.svg': 'Homepage â†’ Quote popup / offer image',
      'images/service-lawn-mowing.svg': 'Homepage â†’ Services card: Lawn mowing',
      'images/service-hedge-trimming.svg': 'Homepage â†’ Services card: Hedge trimming',
      'images/service-weed-control.svg': 'Homepage â†’ Services card: Weed control',
    };

    function getImageUsageLabel(imagePath) {
      const key = (imagePath || '').trim();
      return IMAGE_USAGE_LABELS[key] || '';
    }

    async function fetchSiteImages() {
      const res = await fetch('/admin/assets/images');
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        throw new Error(data.message || 'Unable to load images.');
      }
      return Array.isArray(data.images) ? data.images : [];
    }

    function getDroppedImageFile(event) {
      const dt = event && event.dataTransfer;
      if (!dt || !dt.files || !dt.files.length) return null;
      const file = dt.files[0];
      if (!file) return null;
      if (file.type && !file.type.startsWith('image/')) {
        return null;
      }
      return file;
    }

    async function uploadImageFile(file, targetPath) {
      if (!file) {
        throw new Error('No file provided.');
      }
      const form = new FormData();
      form.append('file', file);
      if (targetPath) {
        form.append('target_path', targetPath);
      }
      const res = await fetch('/admin/assets/images/upload', { method: 'POST', body: form });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        throw new Error(data.message || (targetPath ? 'Unable to replace image.' : 'Unable to upload image.'));
      }
      return data;
    }

    function renderSiteImages(images) {
      if (!imageLibraryGrid) return;
      const items = Array.isArray(images) ? images : [];
      imageLibraryGrid.innerHTML = '';

      if (!items.length) {
        setImagesSummary('No images found in /static/images.');
        return;
      }

      setImagesSummary(`${items.length} image${items.length === 1 ? '' : 's'} available.`);

      items.forEach((img) => {
        const card = document.createElement('div');
        card.className = 'image-library-card';

        const thumb = document.createElement('div');
        thumb.className = 'image-library-thumb';

        const imageEl = document.createElement('img');
        imageEl.alt = img.path || 'Site image';
        imageEl.src = `${img.url || ''}?v=${encodeURIComponent(img.modified || '')}`;
        thumb.appendChild(imageEl);

        const meta = document.createElement('div');
        meta.className = 'image-library-meta';
        const title = document.createElement('strong');
        title.textContent = img.path || 'images/';
        const subtitle = document.createElement('small');
        const parts = [];
        if (img.size != null) parts.push(formatBytes(img.size));
        if (img.modified) parts.push(`Updated ${formatDate(img.modified)}`);
        subtitle.textContent = parts.join(' Â· ') || ' '; 

        const usage = document.createElement('small');
        usage.className = 'image-library-usage';
        const usageLabel = getImageUsageLabel(img.path);
        if (usageLabel) {
          usage.textContent = `Used for: ${usageLabel}`;
        } else {
          card.classList.add('is-unmapped');
          usage.textContent = 'Used for: (not mapped yet) â€” uploaded but not referenced by the homepage right now.';
        }
        meta.appendChild(title);
        meta.appendChild(subtitle);
        meta.appendChild(usage);

        const actions = document.createElement('div');
        actions.className = 'image-library-actions';

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';

        const replaceBtn = document.createElement('button');
        replaceBtn.type = 'button';
        replaceBtn.className = 'secondary';
        replaceBtn.textContent = 'Replace image';

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'secondary';
        deleteBtn.textContent = 'Delete';

        const doReplace = async (file) => {
          if (!file) {
            showImagesFeedback('Drop an image here or choose a file first.');
            return;
          }
          replaceBtn.disabled = true;
          deleteBtn.disabled = true;
          try {
            await uploadImageFile(file, img.path || '');
            showImagesFeedback('Image replaced.', true);
            await loadSiteImages();
          } catch (error) {
            showImagesFeedback(error.message || 'Unable to replace image.');
          } finally {
            replaceBtn.disabled = false;
            deleteBtn.disabled = false;
          }
        };

        replaceBtn.addEventListener('click', async () => {
          const file = fileInput.files && fileInput.files[0];
          await doReplace(file);
        });

        // Drag & drop replacement onto the whole card.
        let dragDepth = 0;
        const setDropActive = (active) => {
          card.classList.toggle('is-drop-target', Boolean(active));
        };

        card.addEventListener('dragenter', (event) => {
          event.preventDefault();
          dragDepth += 1;
          setDropActive(true);
        });
        card.addEventListener('dragover', (event) => {
          event.preventDefault();
          if (event.dataTransfer) {
            event.dataTransfer.dropEffect = 'copy';
          }
          setDropActive(true);
        });
        card.addEventListener('dragleave', () => {
          dragDepth = Math.max(0, dragDepth - 1);
          if (dragDepth === 0) {
            setDropActive(false);
          }
        });
        card.addEventListener('drop', async (event) => {
          event.preventDefault();
          event.stopPropagation();
          dragDepth = 0;
          setDropActive(false);
          const file = getDroppedImageFile(event);
          if (!file) {
            showImagesFeedback('Please drop an image file (png/jpg/webp/svg).');
            return;
          }
          await doReplace(file);
        });

        deleteBtn.addEventListener('click', async () => {
          if (!confirm(`Delete ${img.path}?`)) return;
          replaceBtn.disabled = true;
          deleteBtn.disabled = true;
          try {
            const res = await fetch('/admin/assets/images/delete', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ path: img.path }),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) throw new Error(data.message || 'Unable to delete image.');
            showImagesFeedback('Image deleted.', true);
            await loadSiteImages();
          } catch (error) {
            showImagesFeedback(error.message || 'Unable to delete image.');
          } finally {
            replaceBtn.disabled = false;
            deleteBtn.disabled = false;
          }
        });

        actions.appendChild(fileInput);
        actions.appendChild(replaceBtn);
        actions.appendChild(deleteBtn);

        card.appendChild(thumb);
        card.appendChild(meta);
        card.appendChild(actions);
        imageLibraryGrid.appendChild(card);
      });
    }

    async function loadSiteImages() {
      try {
        const images = await fetchSiteImages();
        renderSiteImages(images);
      } catch (error) {
        setImagesSummary('Unable to load images.');
        showImagesFeedback(error.message || 'Unable to load images.');
      }
    }

    async function uploadNewImage() {
      const file = uploadNewImageInput && uploadNewImageInput.files ? uploadNewImageInput.files[0] : null;
      if (!file) {
        showImagesFeedback('Choose an image to upload first.');
        return;
      }
      if (uploadNewImageBtn) uploadNewImageBtn.disabled = true;
      try {
        await uploadImageFile(file);
        showImagesFeedback('Image uploaded.', true);
        if (uploadNewImageInput) uploadNewImageInput.value = '';
        await loadSiteImages();
      } catch (error) {
        showImagesFeedback(error.message || 'Unable to upload image.');
      } finally {
        if (uploadNewImageBtn) uploadNewImageBtn.disabled = false;
      }
    }

    async function uploadNewImageFile(file) {
      if (!file) {
        showImagesFeedback('Please drop an image file.');
        return;
      }
      if (uploadNewImageBtn) uploadNewImageBtn.disabled = true;
      try {
        await uploadImageFile(file);
        showImagesFeedback('Image uploaded.', true);
        await loadSiteImages();
      } catch (error) {
        showImagesFeedback(error.message || 'Unable to upload image.');
      } finally {
        if (uploadNewImageBtn) uploadNewImageBtn.disabled = false;
      }
    }

    function updateChatSummary() {
      if (!chatSummaryHighlight) return;
      if (!chatSessionsCache.length) {
        if (chatOnline) {
          setSummaryText(chatSummaryHighlight, 'Online and ready for the next chat.');
        } else {
          setSummaryText(chatSummaryHighlight, 'Chat is offline. Visitors see an offline notice.');
        }
        updateChatAttentionIndicator(0);
        return;
      }

      const unreadTotal = chatSessionsCache.reduce(
        (total, session) => total + (Number(session && session.unread_from_visitor) || 0),
        0
      );
      const unreadSuffix = unreadTotal
        ? ` â€¢ ${unreadTotal} new message${unreadTotal === 1 ? '' : 's'}`
        : '';
      const descriptor = chatOnline ? 'live' : 'saved';
      setSummaryText(
        chatSummaryHighlight,
        `${chatSessionsCache.length} ${descriptor} ${chatSessionsCache.length === 1 ? 'chat' : 'chats'} active${unreadSuffix}.`
      );
      updateChatAttentionIndicator(unreadTotal);
    }

    function updateAutopilotSummary() {
      if (!autopilotSummaryHighlight) return;
      const enabled = Boolean(autopilotConfig.enabled);
      const provider = typeof autopilotConfig.provider === 'string' ? autopilotConfig.provider : 'deepseek';
      const hasProfile =
        typeof autopilotConfig.business_profile === 'string' && autopilotConfig.business_profile.trim().length > 0;
      const hasWebsiteKnowledge = Boolean(autopilotConfig.has_business_website_knowledge);
      const hasKnowledge = hasProfile || hasWebsiteKnowledge;

      const deepseekKeyTyped =
        autopilotApiKeyInput && autopilotApiKeyInput.value && autopilotApiKeyInput.value.trim().length > 0;
      const deepseekKeyPendingRemoval =
        autopilotApiKeyInput &&
        autopilotApiKeyInput.dataset.dirty === 'true' &&
        autopilotApiKeyInput.dataset.hasExisting === 'false' &&
        !deepseekKeyTyped;
      const hasDeepseekKey = (!deepseekKeyPendingRemoval && Boolean(autopilotConfig.has_api_key)) || Boolean(deepseekKeyTyped);

      const openrouterKeyTyped =
        openrouterApiKeyInput && openrouterApiKeyInput.value && openrouterApiKeyInput.value.trim().length > 0;
      const openrouterKeyPendingRemoval =
        openrouterApiKeyInput &&
        openrouterApiKeyInput.dataset.dirty === 'true' &&
        openrouterApiKeyInput.dataset.hasExisting === 'false' &&
        !openrouterKeyTyped;
      const hasOpenrouterKey =
        (!openrouterKeyPendingRemoval && Boolean(autopilotConfig.has_openrouter_api_key)) || Boolean(openrouterKeyTyped);

      const hasKey = provider === 'openrouter' ? hasOpenrouterKey : hasDeepseekKey;

      if (enabled && hasKnowledge && hasKey) {
        setSummaryText(
          autopilotSummaryHighlight,
          hasWebsiteKnowledge
            ? 'Autopilot is answering chats using your business notes and website knowledge.'
            : 'Autopilot is answering chats using your saved business guide.'
        );
      } else if (enabled && !hasKey) {
        setSummaryText(
          autopilotSummaryHighlight,
          provider === 'openrouter'
            ? 'Autopilot is on, but add an OpenRouter API key so replies can be generated.'
            : 'Autopilot is on, but add a DeepSeek API key so replies can be generated.'
        );
      } else if (enabled) {
        setSummaryText(
          autopilotSummaryHighlight,
          'Autopilot is on. Add more business info so replies stay accurate.'
        );
      } else {
        setSummaryText(autopilotSummaryHighlight, 'Autopilot is paused. You will reply to visitors manually.');
      }
    }

    function renderWeatherState() {
      const hasKey = Boolean(weatherConfig.has_api_key);
      const savedKeys = Array.isArray(weatherConfig.api_keys) ? weatherConfig.api_keys : [];

      if (weatherStatus) {
        weatherStatus.textContent = hasKey ? 'API key saved' : 'No API key saved';
        weatherStatus.classList.toggle('online', hasKey);
        weatherStatus.classList.toggle('offline', !hasKey);
      }

      if (weatherApiKeyInput) {
        weatherApiKeyInput.dataset.dirty = 'false';
        weatherApiKeyInput.dataset.hasExisting = hasKey ? 'true' : 'false';
      }

      if (weatherFeedback) {
        weatherFeedback.classList.remove('visible', 'success');
        weatherFeedback.textContent = '';
      }

      renderWeatherSavedKeys(savedKeys);
    }

    function renderWeatherSavedKeys(keys = []) {
      if (!weatherApiKeyList || !weatherApiKeyListEmpty) return;

      const normalized = Array.isArray(keys) ? keys : [];
      weatherApiKeyList.innerHTML = '';

      if (!normalized.length) {
        weatherApiKeyList.hidden = true;
        weatherApiKeyListEmpty.hidden = false;
        return;
      }

      weatherApiKeyList.hidden = false;
      weatherApiKeyListEmpty.hidden = true;

      normalized.forEach((entry) => {
        const item = document.createElement('li');
        item.className = 'api-key-pill';

        const name = document.createElement('strong');
        name.textContent = entry && entry.label ? entry.label : 'Saved API key';

        const meta = document.createElement('small');
        const createdAt = entry && entry.created_at ? formatDate(entry.created_at) : '';
        const last4 = entry && entry.last4 ? `ending ${entry.last4}` : '';
        const details = [last4, createdAt].filter(Boolean).join(' Â· ');
        meta.textContent = details || 'Ready to use for weather overlays';

        item.appendChild(name);
        item.appendChild(meta);
        weatherApiKeyList.appendChild(item);
      });
    }

    function applyApiKeyToPayload(payload) {
      if (!payload || typeof payload !== 'object') return payload;

      if (autopilotProviderSelect) {
        const value = String(autopilotProviderSelect.value || '').trim();
        if (value === 'openrouter' || value === 'deepseek') {
          payload.provider = value;
        }
      }

      const apiKeyValue = autopilotApiKeyInput ? autopilotApiKeyInput.value.trim() : '';
      const apiKeyDirty = autopilotApiKeyInput && autopilotApiKeyInput.dataset.dirty === 'true';
      const hasExistingKey = autopilotApiKeyInput && autopilotApiKeyInput.dataset.hasExisting === 'true';

      // Always propagate a populated API key value (covers password manager autofill) even if
      // the input never fired an `input` event to set the dirty flag.
      if (apiKeyDirty || (apiKeyValue.length > 0 && !hasExistingKey)) {
        payload.api_key = apiKeyValue;
      }

      const openrouterApiKeyValue = openrouterApiKeyInput ? openrouterApiKeyInput.value.trim() : '';
      const openrouterApiKeyDirty = openrouterApiKeyInput && openrouterApiKeyInput.dataset.dirty === 'true';
      const openrouterHasExistingKey = openrouterApiKeyInput && openrouterApiKeyInput.dataset.hasExisting === 'true';

      if (openrouterApiKeyDirty || (openrouterApiKeyValue.length > 0 && !openrouterHasExistingKey)) {
        payload.openrouter_api_key = openrouterApiKeyValue;
      }

      return payload;
    }

    function setAutopilotBusy(isBusy) {
      autopilotBusy = Boolean(isBusy);
      autopilotToggleButtons.forEach((button) => {
        if (button instanceof HTMLButtonElement) {
          button.disabled = autopilotBusy;
        }
      });
      if (autopilotSaveButton) {
        autopilotSaveButton.disabled = autopilotBusy;
      }
    }

    function renderAutopilotSavedKeys() {
      if (!autopilotApiKeyList || !autopilotApiKeyListEmpty) return;

      const keys = Array.isArray(autopilotConfig.api_keys) ? autopilotConfig.api_keys : [];
      autopilotApiKeyList.innerHTML = '';

      if (!keys.length) {
        autopilotApiKeyList.hidden = true;
        autopilotApiKeyListEmpty.hidden = false;
        return;
      }

      autopilotApiKeyList.hidden = false;
      autopilotApiKeyListEmpty.hidden = true;

      keys.forEach((entry) => {
        const item = document.createElement('li');
        item.className = 'api-key-pill';

        const name = document.createElement('strong');
        name.textContent = entry && entry.label ? entry.label : 'Saved API key';

        const meta = document.createElement('small');
        const createdAt = entry && entry.created_at ? formatDate(entry.created_at) : '';
        const last4 = entry && entry.last4 ? `ending ${entry.last4}` : '';
        const details = [last4, createdAt].filter(Boolean).join(' Â· ');
        meta.textContent = details || 'Ready to use for autopilot replies';

        item.appendChild(name);
        item.appendChild(meta);
        autopilotApiKeyList.appendChild(item);
      });
    }

    function renderOpenrouterSavedKeys() {
      if (!openrouterApiKeyList || !openrouterApiKeyListEmpty) return;

      const keys = Array.isArray(autopilotConfig.openrouter_api_keys) ? autopilotConfig.openrouter_api_keys : [];
      openrouterApiKeyList.innerHTML = '';

      if (!keys.length) {
        openrouterApiKeyList.hidden = true;
        openrouterApiKeyListEmpty.hidden = false;
        return;
      }

      openrouterApiKeyList.hidden = false;
      openrouterApiKeyListEmpty.hidden = true;

      keys.forEach((entry) => {
        const item = document.createElement('li');
        item.className = 'api-key-pill';

        const name = document.createElement('strong');
        name.textContent = entry && entry.label ? entry.label : 'Saved API key';

        const meta = document.createElement('small');
        const createdAt = entry && entry.created_at ? formatDate(entry.created_at) : '';
        const last4 = entry && entry.last4 ? `ending ${entry.last4}` : '';
        const details = [last4, createdAt].filter(Boolean).join(' Â· ');
        meta.textContent = details || 'Ready to use for autopilot replies';

        item.appendChild(name);
        item.appendChild(meta);
        openrouterApiKeyList.appendChild(item);
      });
    }

    function renderAutopilotState() {
      const enabled = Boolean(autopilotConfig.enabled);
      const hasApiKey = Boolean(autopilotConfig.has_api_key);
      const apiKeys = Array.isArray(autopilotConfig.api_keys) ? autopilotConfig.api_keys : [];
      const savedKeyCount = apiKeys.length;
      const provider = typeof autopilotConfig.provider === 'string' ? autopilotConfig.provider : 'deepseek';
      const hasOpenrouterApiKey = Boolean(autopilotConfig.has_openrouter_api_key);
      const openrouterKeys = Array.isArray(autopilotConfig.openrouter_api_keys) ? autopilotConfig.openrouter_api_keys : [];
      const openrouterSavedCount = openrouterKeys.length;
      if (autopilotStatusBadge) {
        autopilotStatusBadge.textContent = enabled ? 'Autopilot active' : 'Autopilot paused';
        autopilotStatusBadge.classList.toggle('active', enabled);
        autopilotStatusBadge.classList.toggle('offline', !enabled);
      }
      autopilotToggleButtons.forEach((button) => {
        if (!(button instanceof HTMLButtonElement)) return;
        button.textContent = enabled ? 'Disable autopilot' : 'Enable autopilot';
        button.classList.toggle('primary', !enabled);
        button.disabled = autopilotBusy;
      });
      if (autopilotPromptInput && typeof autopilotConfig.business_profile === 'string') {
        autopilotPromptInput.value = autopilotConfig.business_profile;
      }

      if (autopilotWebsiteUrlInput) {
        autopilotWebsiteUrlInput.value = typeof autopilotConfig.business_website_url === 'string'
          ? autopilotConfig.business_website_url
          : '';
      }
      const hasWebsiteKnowledge = Boolean(autopilotConfig.has_business_website_knowledge);
      const websiteChars = Number(autopilotConfig.business_website_knowledge_chars) || 0;
      const lastScraped = typeof autopilotConfig.business_website_last_scraped === 'string'
        ? autopilotConfig.business_website_last_scraped
        : '';
      if (autopilotWebsiteStatus) {
        autopilotWebsiteStatus.textContent = hasWebsiteKnowledge
          ? 'Website knowledge saved'
          : 'Not scraped yet';
        autopilotWebsiteStatus.classList.toggle('active', hasWebsiteKnowledge);
        autopilotWebsiteStatus.classList.toggle('offline', !hasWebsiteKnowledge);
      }
      if (autopilotWebsiteMeta) {
        if (hasWebsiteKnowledge) {
          const parts = [];
          if (websiteChars) parts.push(`${websiteChars.toLocaleString()} characters`);
          if (lastScraped) parts.push(`Last scraped: ${formatDate(lastScraped)}`);
          autopilotWebsiteMeta.textContent = parts.join(' Â· ') || 'Website knowledge saved for autopilot.';
        } else {
          autopilotWebsiteMeta.textContent = 'No website knowledge saved yet.';
        }
      }
      if (autopilotWebsitePreview) {
        autopilotWebsitePreview.value = typeof autopilotConfig.business_website_knowledge_preview === 'string'
          ? autopilotConfig.business_website_knowledge_preview
          : '';
      }

      if (autopilotProviderSelect) {
        autopilotProviderSelect.value = provider === 'openrouter' ? 'openrouter' : 'deepseek';
      }
      if (autopilotApiKeyStatus) {
        if (hasApiKey && savedKeyCount > 0) {
          autopilotApiKeyStatus.textContent =
            savedKeyCount === 1 ? '1 saved API key' : `${savedKeyCount} saved API keys`;
        } else if (hasApiKey) {
          autopilotApiKeyStatus.textContent = 'Key available for autopilot replies';
        } else {
          autopilotApiKeyStatus.textContent = 'No key saved';
        }
        autopilotApiKeyStatus.classList.toggle('active', hasApiKey);
        autopilotApiKeyStatus.classList.toggle('offline', !hasApiKey);
      }
      if (autopilotApiKeyInput) {
        const keepTypedValue =
          autopilotApiKeyInput.dataset.dirty === 'true' &&
          autopilotApiKeyInput.value &&
          autopilotApiKeyInput.value.trim().length > 0;

        if (!keepTypedValue) {
          autopilotApiKeyInput.value = '';
        }

        autopilotApiKeyInput.dataset.dirty = keepTypedValue ? 'true' : 'false';
        autopilotApiKeyInput.dataset.hasExisting = hasApiKey ? 'true' : 'false';
      }
      if (autopilotApiKeyNote) {
        autopilotApiKeyNote.textContent = hasApiKey
          ? 'API key saved securely for future autopilot replies. Leave the box untouched to keep it. The DEEPSEEK_API_KEY environment variable (or OPENAI_API_KEY for legacy setups) will also be used if set.'
          : 'Add your DeepSeek API key so autopilot can reply to visitors.';
        autopilotApiKeyNote.classList.toggle('warning', !hasApiKey);
      }

      if (openrouterApiKeyStatus) {
        if (hasOpenrouterApiKey && openrouterSavedCount > 0) {
          openrouterApiKeyStatus.textContent =
            openrouterSavedCount === 1 ? '1 saved API key' : `${openrouterSavedCount} saved API keys`;
        } else if (hasOpenrouterApiKey) {
          openrouterApiKeyStatus.textContent = 'Key available for autopilot replies';
        } else {
          openrouterApiKeyStatus.textContent = 'No key saved';
        }
        openrouterApiKeyStatus.classList.toggle('active', hasOpenrouterApiKey);
        openrouterApiKeyStatus.classList.toggle('offline', !hasOpenrouterApiKey);
      }

      if (openrouterApiKeyInput) {
        const keepTypedValue =
          openrouterApiKeyInput.dataset.dirty === 'true' &&
          openrouterApiKeyInput.value &&
          openrouterApiKeyInput.value.trim().length > 0;

        if (!keepTypedValue) {
          openrouterApiKeyInput.value = '';
        }

        openrouterApiKeyInput.dataset.dirty = keepTypedValue ? 'true' : 'false';
        openrouterApiKeyInput.dataset.hasExisting = hasOpenrouterApiKey ? 'true' : 'false';
      }

      if (openrouterApiKeyNote) {
        openrouterApiKeyNote.textContent = hasOpenrouterApiKey
          ? 'API key saved securely for future autopilot replies. Leave the box untouched to keep it. The OPENROUTER_API_KEY environment variable will also be used if set.'
          : 'Add your OpenRouter API key so autopilot can reply to visitors.';
        openrouterApiKeyNote.classList.toggle('warning', !hasOpenrouterApiKey);
      }

      renderAutopilotSavedKeys();
      renderOpenrouterSavedKeys();
    }

    async function scrapeAutopilotWebsite(url) {
      const value = typeof url === 'string' ? url.trim() : '';
      if (!value) {
        throw new Error('Please enter a website address first.');
      }
      const res = await fetch('/admin/autopilot/scrape', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url: value }),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        throw new Error(data.message || 'Unable to scrape that website.');
      }
      const incoming = data && typeof data.config === 'object' ? data.config : {};
      autopilotConfig = { ...AUTOPILOT_DEFAULTS, ...incoming };
      renderAutopilotState();
      updateAutopilotSummary();
      return true;
    }

    async function clearAutopilotWebsiteKnowledge() {
      const res = await fetch('/admin/autopilot/scrape/clear', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        throw new Error(data.message || 'Unable to clear website knowledge.');
      }
      const incoming = data && typeof data.config === 'object' ? data.config : {};
      autopilotConfig = { ...AUTOPILOT_DEFAULTS, ...incoming };
      renderAutopilotState();
      updateAutopilotSummary();
      return true;
    }

    async function loadWeatherConfig() {
      try {
        const res = await fetch('/admin/weather/config');
        if (!res.ok) {
          throw new Error('Unable to load weather settings.');
        }
        const data = await res.json().catch(() => ({}));
        const incoming = data && typeof data.config === 'object' ? data.config : {};
        weatherConfig = { ...WEATHER_DEFAULTS, ...incoming };
        renderWeatherState();
      } catch (error) {
        console.error('Unable to load weather settings.', error);
        if (weatherFeedback) {
          weatherFeedback.textContent = 'Unable to load weather settings.';
          weatherFeedback.classList.add('visible');
        }
      }
    }

    async function persistWeatherConfig(event) {
      if (event) {
        event.preventDefault();
      }

      if (weatherFeedback) {
        weatherFeedback.classList.remove('visible', 'success');
        weatherFeedback.textContent = '';
      }

      const payload = {};
      const apiKeyValue = weatherApiKeyInput ? weatherApiKeyInput.value.trim() : '';
      const apiKeyDirty = weatherApiKeyInput && weatherApiKeyInput.dataset.dirty === 'true';
      const hasExistingKey = weatherApiKeyInput && weatherApiKeyInput.dataset.hasExisting === 'true';

      if (apiKeyDirty || (apiKeyValue.length > 0 && !hasExistingKey)) {
        payload.api_key = apiKeyValue;
      }

      try {
        const res = await fetch('/admin/weather/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to save weather settings.');
        }

        const incoming = data && typeof data.config === 'object' ? data.config : {};
        weatherConfig = { ...WEATHER_DEFAULTS, ...incoming };
        renderWeatherState();

        if (weatherFeedback) {
          weatherFeedback.textContent = 'Weather settings saved.';
          weatherFeedback.classList.add('visible', 'success');
        }
        return true;
      } catch (error) {
        console.error('Unable to save weather settings.', error);
        if (weatherFeedback) {
          weatherFeedback.textContent = error.message || 'Unable to save weather settings.';
          weatherFeedback.classList.add('visible');
        }
      }
      return false;
    }

    // SMSAPI.com Configuration
    let smsapiConfig = { oauth_token: '', sender_name: '', has_config: false };

    // Telnyx Configuration
    let telnyxConfig = { api_key: '', from_number: '', has_config: false };

    async function loadTelnyxConfig() {
      try {
        const res = await fetch('/admin/telnyx/config');
        if (!res.ok) {
          throw new Error('Unable to load Telnyx settings.');
        }
        const data = await res.json().catch(() => ({}));
        const incoming = data && typeof data.config === 'object' ? data.config : {};
        telnyxConfig = { ...telnyxConfig, ...incoming };
        renderTelnyxState();
      } catch (error) {
        console.error('Unable to load Telnyx settings.', error);
        const telnyxFeedback = document.getElementById('telnyxFeedback');
        if (telnyxFeedback) {
          telnyxFeedback.textContent = 'Unable to load Telnyx settings.';
          telnyxFeedback.classList.add('visible');
        }
      }
    }

    function renderTelnyxState() {
      const telnyxApiKeyInput = document.getElementById('telnyxApiKey');
      const telnyxFromNumberInput = document.getElementById('telnyxFromNumber');
      const telnyxProfileInput = document.getElementById('telnyxMessagingProfileId');
      const telnyxStatus = document.getElementById('telnyxStatus');

      if (telnyxApiKeyInput && telnyxConfig.api_key) {
        telnyxApiKeyInput.placeholder = telnyxConfig.api_key;
      }
      if (telnyxFromNumberInput) {
        telnyxFromNumberInput.value = telnyxConfig.from_number || '';
      }
      if (telnyxProfileInput) {
        telnyxProfileInput.value = telnyxConfig.messaging_profile_id || '';
      }

      if (telnyxStatus) {
        if (telnyxConfig.has_config) {
          telnyxStatus.textContent = 'âœ“ Telnyx SMS verification is configured and ready to use.';
          telnyxStatus.style.color = '#30c3a6';
        } else {
          telnyxStatus.textContent = 'âš  Telnyx not configured. The site will use SMSAPI.com if configured, otherwise phone verification will be skipped.';
          telnyxStatus.style.color = '#ffd166';
        }
      }
    }

    async function persistTelnyxConfig(event) {
      if (event) {
        event.preventDefault();
      }

      const telnyxFeedback = document.getElementById('telnyxFeedback');
      if (telnyxFeedback) {
        telnyxFeedback.classList.remove('visible', 'success');
        telnyxFeedback.textContent = '';
      }

      const apiKey = document.getElementById('telnyxApiKey')?.value.trim() || '';
      const fromNumber = document.getElementById('telnyxFromNumber')?.value.trim() || '';
      const profileId = document.getElementById('telnyxMessagingProfileId')?.value.trim() || '';

      const payload = {};
      // Only send fields when the admin provided a value, so we don't clear saved secrets.
      if (apiKey) {
        payload.api_key = apiKey;
      }
      if (fromNumber) {
        payload.from_number = fromNumber;
      }
      payload.messaging_profile_id = profileId;

      try {
        const res = await fetch('/admin/telnyx/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to save Telnyx settings.');
        }

        const incoming = data && typeof data.config === 'object' ? data.config : {};
        telnyxConfig = { ...telnyxConfig, ...incoming };
        renderTelnyxState();

        if (telnyxFeedback) {
          telnyxFeedback.textContent = 'Telnyx settings saved successfully.';
          telnyxFeedback.classList.add('visible', 'success');
        }
        // Clear API key field after save.
        const keyEl = document.getElementById('telnyxApiKey');
        if (keyEl) {
          keyEl.value = '';
        }
        return true;
      } catch (error) {
        console.error('Unable to save Telnyx settings.', error);
        if (telnyxFeedback) {
          telnyxFeedback.textContent = error.message || 'Unable to save Telnyx settings.';
          telnyxFeedback.classList.add('visible');
        }
      }
      return false;
    }

    async function runTelnyxDiagnostics() {
      const panel = document.getElementById('telnyxDiagnosticsPanel');
      const list = document.getElementById('telnyxDiagnosticsList');
      const btn = document.getElementById('telnyxDiagnosticsBtn');
      if (!panel || !list) return;

      btn.disabled = true;
      btn.textContent = 'Checkingâ€¦';
      panel.style.display = 'block';
      list.innerHTML = '<p style="color: #aaa;">Loading diagnosticsâ€¦</p>';

      try {
        const res = await fetch('/admin/telnyx/diagnostics');
        const data = await res.json().catch(() => ({}));
        const checks = data.checks || [];

        let html = '';
        for (const c of checks) {
          const icon = c.status === 'ok' ? 'âœ…' : c.status === 'fail' ? 'âŒ' : c.status === 'warn' ? 'âš ï¸' : 'â„¹ï¸';
          const color = c.status === 'ok' ? '#30c3a6' : c.status === 'fail' ? '#ff6b6b' : c.status === 'warn' ? '#ffd166' : '#aaa';
          html += `<div style="color: ${color}; margin-bottom: 4px;">${icon} <strong>${c.label}:</strong> ${c.detail}</div>`;
        }

        if (data.all_ok) {
          html += '<div style="color: #30c3a6; margin-top: 12px; font-weight: 700;">All checks passed â€” config looks good. Try sending a test SMS below.</div>';
        } else {
          html += '<div style="color: #ff6b6b; margin-top: 12px; font-weight: 700;">Some checks failed â€” fix the issues above, then Save and re-check.</div>';
        }

        list.innerHTML = html;
      } catch (err) {
        list.innerHTML = `<p style="color: #ff6b6b;">Error running diagnostics: ${err.message}</p>`;
      } finally {
        btn.disabled = false;
        btn.textContent = 'Check Config';
      }
    }

    async function sendTelnyxTest() {
      const phoneInput = document.getElementById('telnyxTestPhone');
      const resultEl = document.getElementById('telnyxTestResult');
      const btn = document.getElementById('telnyxTestBtn');
      if (!phoneInput || !resultEl) return;

      const phone = phoneInput.value.trim();
      if (!phone) {
        resultEl.textContent = 'âš  Please enter a phone number first.';
        resultEl.style.color = '#ffd166';
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Sendingâ€¦';
      resultEl.textContent = 'ðŸ“¤ Sending test SMSâ€¦';
      resultEl.style.color = '#aaa';

      try {
        const res = await fetch('/admin/telnyx/test', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ phone }),
        });
        const data = await res.json().catch(() => ({}));

        if (data.ok) {
          resultEl.textContent = 'âœ… ' + (data.message || 'Test SMS sent!');
          resultEl.style.color = '#30c3a6';
        } else {
          resultEl.textContent = 'âŒ ' + (data.message || 'Test failed.');
          resultEl.style.color = '#ff6b6b';
        }

        // Show diagnostics if returned
        if (data.diagnostics) {
          const diagInfo = data.diagnostics;
          const extra = `\nAPI key set: ${diagInfo.api_key_set} (${diagInfo.api_key_length} chars) | From: ${diagInfo.from_number || 'empty'} | Profile: ${diagInfo.messaging_profile_id || 'none'}`;
          resultEl.textContent += extra;
        }
      } catch (err) {
        resultEl.textContent = 'âŒ Network error: ' + err.message;
        resultEl.style.color = '#ff6b6b';
      } finally {
        btn.disabled = false;
        btn.textContent = 'Send Test SMS';
      }
    }

    async function loadSmsapiConfig() {
      try {
        const res = await fetch('/admin/smsapi/config');
        if (!res.ok) {
          throw new Error('Unable to load SMSAPI settings.');
        }
        const data = await res.json().catch(() => ({}));
        const incoming = data && typeof data.config === 'object' ? data.config : {};
        smsapiConfig = { ...smsapiConfig, ...incoming };
        renderSmsapiState();
      } catch (error) {
        console.error('Unable to load SMSAPI settings.', error);
        const smsapiFeedback = document.getElementById('smsapiFeedback');
        if (smsapiFeedback) {
          smsapiFeedback.textContent = 'Unable to load SMSAPI settings.';
          smsapiFeedback.classList.add('visible');
        }
      }
    }

    function renderSmsapiState() {
      const smsapiOauthTokenInput = document.getElementById('smsapiOauthToken');
      const smsapiSenderNameInput = document.getElementById('smsapiSenderName');
      const smsapiStatus = document.getElementById('smsapiStatus');

      if (smsapiOauthTokenInput && smsapiConfig.oauth_token) {
        smsapiOauthTokenInput.placeholder = smsapiConfig.oauth_token;
      }
      if (smsapiSenderNameInput && smsapiConfig.sender_name) {
        smsapiSenderNameInput.value = smsapiConfig.sender_name;
      }

      if (smsapiStatus) {
        if (smsapiConfig.has_config) {
          smsapiStatus.textContent = 'âœ“ SMS verification is configured and ready to use (~2-3p per SMS).';
          smsapiStatus.style.color = '#30c3a6';
        } else {
          smsapiStatus.textContent = 'âš  SMS verification not configured. Quotes will be submitted without phone verification.';
          smsapiStatus.style.color = '#ffd166';
        }
      }
    }

    async function persistSmsapiConfig(event) {
      if (event) {
        event.preventDefault();
      }

      const smsapiFeedback = document.getElementById('smsapiFeedback');
      if (smsapiFeedback) {
        smsapiFeedback.classList.remove('visible', 'success');
        smsapiFeedback.textContent = '';
      }

      const oauthToken = document.getElementById('smsapiOauthToken')?.value.trim() || '';
      const senderName = document.getElementById('smsapiSenderName')?.value.trim() || '';

      const payload = {
        oauth_token: oauthToken,
        sender_name: senderName
      };

      try {
        const res = await fetch('/admin/smsapi/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to save SMSAPI settings.');
        }

        const incoming = data && typeof data.config === 'object' ? data.config : {};
        smsapiConfig = { ...smsapiConfig, ...incoming };
        renderSmsapiState();

        if (smsapiFeedback) {
          smsapiFeedback.textContent = 'SMSAPI settings saved successfully.';
          smsapiFeedback.classList.add('visible', 'success');
        }
        return true;
      } catch (error) {
        console.error('Unable to save SMSAPI settings.', error);
        if (smsapiFeedback) {
          smsapiFeedback.textContent = error.message || 'Unable to save SMSAPI settings.';
          smsapiFeedback.classList.add('visible');
        }
      }
      return false;
    }

    // Email (SMTP) Configuration
    let emailConfig = {
      host: '',
      port: 587,
      username: '',
      from_email: '',
      from_name: 'Pay As You Mow',
      use_starttls: true,
      has_password: false,
      has_config: false,
    };

    async function loadEmailConfig() {
      try {
        const res = await fetch('/admin/email/config');
        if (!res.ok) {
          throw new Error('Unable to load email settings.');
        }
        const data = await res.json().catch(() => ({}));
        const incoming = data && typeof data.config === 'object' ? data.config : {};
        emailConfig = { ...emailConfig, ...incoming };
        renderEmailState();
      } catch (error) {
        console.error('Unable to load email settings.', error);
        const emailFeedback = document.getElementById('emailFeedback');
        if (emailFeedback) {
          emailFeedback.textContent = 'Unable to load email settings.';
          emailFeedback.classList.add('visible');
        }
      }
    }

    function renderEmailState() {
      const hostEl = document.getElementById('smtpHost');
      const portEl = document.getElementById('smtpPort');
      const userEl = document.getElementById('smtpUsername');
      const passEl = document.getElementById('smtpPassword');
      const fromEmailEl = document.getElementById('smtpFromEmail');
      const fromNameEl = document.getElementById('smtpFromName');
      const starttlsEl = document.getElementById('smtpUseStarttls');
      const statusEl = document.getElementById('emailStatus');

      if (hostEl) hostEl.value = emailConfig.host || '';
      if (portEl) portEl.value = String(emailConfig.port || 587);
      if (userEl) userEl.value = emailConfig.username || '';
      if (fromEmailEl) fromEmailEl.value = emailConfig.from_email || '';
      if (fromNameEl) fromNameEl.value = emailConfig.from_name || 'Pay As You Mow';
      if (starttlsEl) starttlsEl.checked = Boolean(emailConfig.use_starttls);
      if (passEl) {
        passEl.value = '';
        passEl.placeholder = emailConfig.has_password ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢ (saved)' : 'Enter your app password';
      }

      if (statusEl) {
        if (emailConfig.has_config) {
          statusEl.textContent = 'âœ“ Email verification is configured and ready to use.';
          statusEl.style.color = '#30c3a6';
        } else {
          statusEl.textContent = 'âš  Email verification not configured. Quotes can still be submitted, but won\'t be verified by email.';
          statusEl.style.color = '#ffd166';
        }
      }
    }

    async function persistEmailConfig(event) {
      if (event) {
        event.preventDefault();
      }

      const emailFeedback = document.getElementById('emailFeedback');
      if (emailFeedback) {
        emailFeedback.classList.remove('visible', 'success');
        emailFeedback.textContent = '';
      }

      const passwordValue = document.getElementById('smtpPassword')?.value.trim() || '';
      const payload = {
        host: document.getElementById('smtpHost')?.value.trim() || '',
        port: Number(document.getElementById('smtpPort')?.value || 587),
        username: document.getElementById('smtpUsername')?.value.trim() || '',
        from_email: document.getElementById('smtpFromEmail')?.value.trim() || '',
        from_name: document.getElementById('smtpFromName')?.value.trim() || '',
        use_starttls: Boolean(document.getElementById('smtpUseStarttls')?.checked),
      };

      // Only update password if user entered one (avoids wiping the saved app password).
      if (passwordValue) {
        payload.password = passwordValue;
      }

      try {
        const res = await fetch('/admin/email/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to save email settings.');
        }

        const incoming = data && typeof data.config === 'object' ? data.config : {};
        emailConfig = { ...emailConfig, ...incoming };
        renderEmailState();

        if (emailFeedback) {
          emailFeedback.textContent = 'Email settings saved.';
          emailFeedback.classList.add('visible', 'success');
        }
        return true;
      } catch (error) {
        console.error('Unable to save email settings.', error);
        if (emailFeedback) {
          emailFeedback.textContent = error.message || 'Unable to save email settings.';
          emailFeedback.classList.add('visible');
        }
      }
      return false;
    }

    async function loadAutopilotConfig() {
      try {
        const res = await fetch('/admin/autopilot/config');
        if (!res.ok) {
          throw new Error('Unable to load autopilot settings.');
        }
        const data = await res.json().catch(() => ({}));
        const incoming = data && typeof data.config === 'object' ? data.config : {};
        autopilotConfig = { ...AUTOPILOT_DEFAULTS, ...incoming };
        renderAutopilotState();
        updateAutopilotSummary();
      } catch (error) {
        console.error('Unable to load autopilot settings.', error);
        if (autopilotSummaryHighlight) {
          setSummaryText(autopilotSummaryHighlight, 'Unable to load autopilot settings right now.');
        }
      }
    }

    async function persistAutopilotConfig(payload, showSuccess = false) {
      if (!payload || typeof payload !== 'object') {
        return false;
      }

      const payloadWithKey = applyApiKeyToPayload({ ...payload });
      const submittedApiKey =
        autopilotApiKeyInput && autopilotApiKeyInput.dataset.dirty === 'true'
          ? autopilotApiKeyInput.value.trim()
          : '';
      const submittedOpenrouterApiKey =
        openrouterApiKeyInput && openrouterApiKeyInput.dataset.dirty === 'true'
          ? openrouterApiKeyInput.value.trim()
          : '';

      if (autopilotFeedback) {
        autopilotFeedback.classList.remove('visible', 'success');
        autopilotFeedback.textContent = '';
      }

      setAutopilotBusy(true);
      try {
        const res = await fetch('/admin/autopilot/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payloadWithKey),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to update autopilot settings.');
        }
        const incoming = data && typeof data.config === 'object' ? data.config : {};
        autopilotConfig = { ...AUTOPILOT_DEFAULTS, ...incoming };
        renderAutopilotState();
        if (submittedApiKey && autopilotApiKeyInput) {
          autopilotApiKeyInput.value = submittedApiKey;
          autopilotApiKeyInput.dataset.dirty = 'false';
          autopilotApiKeyInput.dataset.hasExisting = 'true';
        }
        if (submittedOpenrouterApiKey && openrouterApiKeyInput) {
          openrouterApiKeyInput.value = submittedOpenrouterApiKey;
          openrouterApiKeyInput.dataset.dirty = 'false';
          openrouterApiKeyInput.dataset.hasExisting = 'true';
        }
        updateAutopilotSummary();
        const selectedProvider = typeof autopilotConfig.provider === 'string' ? autopilotConfig.provider : 'deepseek';
        const missingKey = autopilotConfig.enabled && (
          selectedProvider === 'openrouter'
            ? !autopilotConfig.has_openrouter_api_key
            : !autopilotConfig.has_api_key
        );
        if (autopilotFeedback) {
          if (missingKey) {
            autopilotFeedback.textContent = selectedProvider === 'openrouter'
              ? 'Add your OpenRouter API key so autopilot can respond to visitors.'
              : 'Add your DeepSeek API key so autopilot can respond to visitors.';
            autopilotFeedback.classList.remove('success');
            autopilotFeedback.classList.add('visible');
          } else if (showSuccess) {
            autopilotFeedback.textContent = 'Autopilot settings saved.';
            autopilotFeedback.classList.add('visible', 'success');
          }
        }
        return true;
      } catch (error) {
        console.error('Unable to update autopilot settings.', error);
        if (autopilotFeedback) {
          autopilotFeedback.textContent = error.message || 'Unable to update autopilot settings.';
          autopilotFeedback.classList.remove('success');
          autopilotFeedback.classList.add('visible');
        }
        return false;
      } finally {
        setAutopilotBusy(false);
      }
    }

    function updatePanelLayoutState() {
      if (!panelGrid) return;
      const expandedPanel = panels.find((candidate) => candidate.getAttribute('data-expanded') === 'true');
      if (expandedPanel) {
        const identifier = expandedPanel.dataset.panelId || expandedPanel.id || 'expanded';
        panelGrid.setAttribute('data-active-panel', identifier);
      } else {
        panelGrid.removeAttribute('data-active-panel');
      }
    }

    function collapsePanel(panel, toggle, body, suppressLayoutUpdate = false) {
      if (!panel || !toggle || !body) return;
      panel.classList.remove('panel--solo');
      panel.setAttribute('data-expanded', 'false');
      toggle.setAttribute('aria-expanded', 'false');
      toggle.dataset.state = 'collapsed';
      toggle.textContent = 'Expand';
      body.hidden = true;
      if (!suppressLayoutUpdate) {
        updatePanelLayoutState();
      }
    }

    function expandPanel(panel, toggle, body) {
      if (!panel || !toggle || !body) return;
      panel.classList.add('panel--solo');
      body.hidden = false;
      toggle.setAttribute('aria-expanded', 'true');
      toggle.dataset.state = 'expanded';
      toggle.textContent = 'Collapse';
      requestAnimationFrame(() => {
        panel.setAttribute('data-expanded', 'true');
        updatePanelLayoutState();
        panel.scrollIntoView({ block: 'start', behavior: 'smooth' });
      });
    }

    function initialisePanelToggles() {
      panels.forEach((panel, index) => {
        if (panel instanceof HTMLElement && !panel.dataset.panelId) {
          panel.dataset.panelId = `panel-${index + 1}`;
        }
      });

      panelToggles.forEach((toggle) => {
        const panel = toggle.closest('[data-panel]');
        const bodyId = toggle.getAttribute('aria-controls');
        const body = bodyId ? document.getElementById(bodyId) : null;
        if (!panel || !body) {
          return;
        }

        collapsePanel(panel, toggle, body, true);

        toggle.addEventListener('click', () => {
          const isExpanded = panel.getAttribute('data-expanded') === 'true';
          if (isExpanded) {
            collapsePanel(panel, toggle, body);
            return;
          }

          if (panelGrid) {
            const identifier = panel.dataset.panelId || panel.id || 'expanded';
            panelGrid.setAttribute('data-active-panel', identifier);
          }
          panel.classList.add('panel--solo');

          panels.forEach((otherPanel) => {
            if (otherPanel === panel) return;
            const bodyElement = otherPanel.querySelector('.panel-body');
            if (!bodyElement) return;
            const otherToggle = otherPanel.querySelector(
              `.panel-toggle[aria-controls="${bodyElement.id}"]`
            );
            if (otherPanel.getAttribute('data-expanded') === 'true' && otherToggle) {
              collapsePanel(otherPanel, otherToggle, bodyElement, true);
            }
          });

          expandPanel(panel, toggle, body);
        });
      });

      updatePanelLayoutState();
    }

    initialisePanelToggles();

    function getAudioContext() {
      const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextCtor) {
        return null;
      }
      if (!audioContextInstance) {
        audioContextInstance = new AudioContextCtor();
      }
      return audioContextInstance;
    }

    function unlockAudioContext() {
      const ctx = getAudioContext();
      if (ctx && ctx.state === 'suspended') {
        ctx.resume().catch(() => {});
      }
    }

    function beepOnce() {
      const ctx = getAudioContext();
      if (!ctx) {
        return;
      }
      const oscillator = ctx.createOscillator();
      const gain = ctx.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.value = 880;
      oscillator.connect(gain);
      gain.connect(ctx.destination);
      const now = ctx.currentTime;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.15, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
      oscillator.start(now);
      oscillator.stop(now + 0.35);
    }

    document.addEventListener('click', unlockAudioContext, { once: true });

    async function loadOnlineVisitors() {
      if (!onlineVisitorsContainer) return;
      onlineVisitorsContainer.className = 'empty-state';
      onlineVisitorsContainer.textContent = 'Checking for active visitorsâ€¦';
      setSummaryText(presenceSummaryHighlight, 'Checking for active visitorsâ€¦');
      try {
        const res = await fetch('/presence');
        if (!res.ok) throw new Error('Unable to fetch online visitors');
        const data = await res.json();
        const visitors = Array.isArray(data.visitors) ? data.visitors : [];
        renderOnlineVisitors(visitors);
      } catch (error) {
        onlineVisitorsContainer.textContent = error.message || 'Failed to load visitors';
        onlineVisitorsCache = [];
        setSummaryText(presenceSummaryHighlight, error.message || 'Unable to load visitors right now.');
      }
    }

    function renderOnlineVisitors(visitors) {
      if (!onlineVisitorsContainer) return;
      const list = Array.isArray(visitors) ? visitors : [];
      onlineVisitorsCache = list;
      updatePresenceSummary(list);
      const currentIps = new Set(list.map((visitor) => visitor.ip));
      if (onlinePresenceInitialised) {
        const hasNewVisitor = list.some((visitor) => !previousVisitorIps.has(visitor.ip));
        if (hasNewVisitor) {
          beepOnce();
        }
      }
      previousVisitorIps = currentIps;
      onlinePresenceInitialised = true;

      if (!list.length) {
        onlineVisitorsContainer.className = 'empty-state';
        onlineVisitorsContainer.textContent = 'No active visitors at the moment.';
        return;
      }

      onlineVisitorsContainer.className = 'table-scroll';
      onlineVisitorsContainer.innerHTML = `
        <div class="presence-note">
          Invite active visitors to join your live chat so you can offer help in real time.
        </div>
        <table>
          <thead>
            <tr>
              <th>IP address</th>
              <th>Location</th>
              <th>Last seen</th>
              <th>Page</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            ${list
              .map((visitor) => {
                const ip = escapeHtml(visitor.ip || 'â€”');
                const location = escapeHtml(visitor.location || 'Unknown location');
                const lastSeen = escapeHtml(formatTime(visitor.last_seen));
                const page = escapeHtml(visitor.page || '/');
                return `
                  <tr>
                    <td>${ip}</td>
                    <td>${location}</td>
                    <td>${lastSeen}</td>
                    <td>${page}</td>
                    <td>
                      <button type="button" class="visitor-invite-btn" data-ip="${ip}">
                        Invite to chat
                      </button>
                    </td>
                  </tr>
              `;
            })
            .join('')}
        </tbody>
      </table>
      `;
    }

    async function loadVisitorHistory() {
      if (!visitorHistoryContainer) return;
      visitorHistoryContainer.className = 'empty-state';
      visitorHistoryContainer.textContent = 'Loading visitor historyâ€¦';
      try {
        const res = await fetch('/admin/visitors');
        if (!res.ok) throw new Error('Unable to fetch visitor history');
        const data = await res.json();
        const visitors = Array.isArray(data.visitors) ? data.visitors : [];
        const bannedList = Array.isArray(data.banned) ? data.banned : [];
        setBannedIpCache(bannedList);
        renderVisitorHistory(visitors);
      } catch (error) {
        visitorHistoryContainer.className = 'empty-state';
        visitorHistoryContainer.textContent = error.message || 'Failed to load visitor history';
        visitorHistoryCache = [];
        updatePresenceSummary(onlineVisitorsCache);
      }
    }

    function renderVisitorHistory(history) {
      if (!visitorHistoryContainer) return;
      const list = Array.isArray(history) ? history : [];
      visitorHistoryCache = list;
      updatePresenceSummary(onlineVisitorsCache);

      if (!list.length) {
        visitorHistoryContainer.className = 'empty-state';
        visitorHistoryContainer.textContent = 'No index page visits recorded yet.';
        return;
      }

      visitorHistoryContainer.className = 'table-scroll';
      visitorHistoryContainer.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>IP address</th>
              <th>First visit</th>
              <th>Last seen</th>
              <th>Time on site</th>
              <th>Visits logged</th>
              <th>Location</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            ${list
              .map((visitor) => {
                const ipValue = visitor && typeof visitor.ip === 'string' ? visitor.ip.trim() : '';
                const ipDisplay = ipValue ? escapeHtml(ipValue) : 'â€”';
                const ipTitle = ipValue ? ` title="${escapeHtml(ipValue)}"` : '';
                const firstSeenRaw = visitor && typeof visitor.first_seen === 'string' ? visitor.first_seen : '';
                const firstVisit = escapeHtml(formatDate(firstSeenRaw));
                const firstSeenTitle = firstSeenRaw ? ` title="${escapeHtml(firstSeenRaw)}"` : '';
                const lastSeenRaw = visitor && typeof visitor.last_seen === 'string' ? visitor.last_seen : '';
                const lastSeen = escapeHtml(formatDate(lastSeenRaw));
                const lastSeenTitle = lastSeenRaw ? ` title="${escapeHtml(lastSeenRaw)}"` : '';
                const visits = Number(visitor && visitor.visit_count ? visitor.visit_count : 0);
                const totalSeconds = Number(visitor && visitor.total_duration_seconds ? visitor.total_duration_seconds : 0);
                const currentVisit = visitor && visitor.current_visit && typeof visitor.current_visit === 'object'
                  ? visitor.current_visit
                  : null;
                const currentSeconds = currentVisit && currentVisit.duration_seconds
                  ? Number(currentVisit.duration_seconds)
                  : 0;
                const timeOnSite = escapeHtml(formatDuration(totalSeconds + currentSeconds));
                const locationRaw =
                  visitor && typeof visitor.location === 'string' && visitor.location.trim()
                    ? visitor.location.trim()
                    : 'Unknown location';
                const location = escapeHtml(locationRaw);
                const bannedEntry = ipValue ? getBannedEntry(ipValue) : null;
                const bannedFlag =
                  visitor && typeof visitor.banned === 'boolean' ? visitor.banned : Boolean(bannedEntry);
                const bannedAtRaw = bannedEntry && typeof bannedEntry.banned_at === 'string' ? bannedEntry.banned_at : '';
                const bannedReason = bannedEntry && typeof bannedEntry.reason === 'string' ? bannedEntry.reason.trim() : '';
                const bannedAtDisplay = bannedAtRaw ? formatDate(bannedAtRaw) : '';
                const statusLabel = bannedFlag ? 'Banned' : 'Allowed';
                const statusClass = bannedFlag ? 'banned' : 'allowed';
                const statusDetails = [];
                if (bannedAtDisplay) {
                  statusDetails.push(`Since ${bannedAtDisplay}`);
                }
                if (bannedReason) {
                  statusDetails.push(bannedReason);
                }
                const statusTitle = statusDetails.length
                  ? statusDetails.join(' â€¢ ')
                  : bannedFlag
                    ? 'Access revoked'
                    : 'Access permitted';
                const statusTitleAttr = statusTitle ? ` title="${escapeHtml(statusTitle)}"` : '';
                const safeIpAttr = ipValue ? escapeHtml(ipValue) : '';
                const disableActions = !ipValue;
                const deleteButton = disableActions
                  ? ''
                  : `<button type="button" class="table-action secondary" data-visitor-action="delete" data-ip="${safeIpAttr}">Delete</button>`;
                const banButton = disableActions
                  ? ''
                  : bannedFlag
                    ? `<button type="button" class="table-action" data-visitor-action="unban" data-ip="${safeIpAttr}">Unban</button>`
                    : `<button type="button" class="table-action danger" data-visitor-action="ban" data-ip="${safeIpAttr}">Ban</button>`;
                const actionsCell = disableActions
                  ? '<span class="cell-muted">No actions available</span>'
                  : `<div class="table-actions">${deleteButton}${banButton}</div>`;
                return `
                  <tr>
                    <td${ipTitle}>${ipDisplay}</td>
                    <td${firstSeenTitle}>${firstVisit}</td>
                    <td${lastSeenTitle}>${lastSeen}</td>
                    <td>${timeOnSite}</td>
                    <td>${visits}</td>
                    <td>${location}</td>
                    <td><span class="visitor-status ${statusClass}"${statusTitleAttr}>${statusLabel}</span></td>
                    <td>${actionsCell}</td>
                  </tr>
                `;
              })
              .join('')}
          </tbody>
        </table>
      `;
    }

    async function refreshPresenceData() {
      await Promise.allSettled([loadOnlineVisitors(), loadVisitorHistory()]);
    }

    if (onlineVisitorsContainer) {
      onlineVisitorsContainer.addEventListener('click', async (event) => {
        const target = event.target instanceof HTMLElement ? event.target : null;
        if (!target) return;

        const button = target.closest('.visitor-invite-btn');
        if (!(button instanceof HTMLButtonElement)) {
          return;
        }

        const ip = button.getAttribute('data-ip');
        if (!ip) {
          return;
        }

        const promptMessage = prompt('Message to display to the visitor:', DEFAULT_CHAT_INVITE_MESSAGE);
        if (promptMessage === null) {
          return;
        }

        const message = promptMessage.trim();
        if (!message) {
          button.textContent = 'Message required';
          setTimeout(() => {
            button.textContent = 'Invite to chat';
          }, 2200);
          return;
        }

        const originalText = button.dataset.originalText || button.textContent || 'Invite to chat';
        if (!button.dataset.originalText) {
          button.dataset.originalText = originalText;
        }

        button.disabled = true;
        button.textContent = 'Sendingâ€¦';

        try {
          const res = await fetch('/admin/chat/invite', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ip, message }),
          });
          const data = await res.json();
          if (!res.ok) {
            throw new Error(data.message || 'Unable to send invite.');
          }

          button.textContent = 'Invite sent';
          setTimeout(() => {
            button.textContent = originalText;
            button.disabled = false;
          }, 2400);

          await loadChatSessions();
          const session = chatSessionsCache.find((item) => item.visitor && item.visitor.ip === ip);
          if (session) {
            selectChatSession(session.session_id);
          }
        } catch (error) {
          console.error('Unable to send invite.', error);
          button.textContent = error.message || 'Failed to send';
          setTimeout(() => {
            button.textContent = originalText;
            button.disabled = false;
          }, 2600);
        }
      });
    }

    if (visitorHistoryContainer) {
      visitorHistoryContainer.addEventListener('click', async (event) => {
        const target = event.target instanceof HTMLElement ? event.target : null;
        if (!target) return;

        const button = target.closest('[data-visitor-action]');
        if (!(button instanceof HTMLButtonElement)) {
          return;
        }

        const action = button.getAttribute('data-visitor-action');
        const ip = button.getAttribute('data-ip');
        if (!action || !ip) {
          return;
        }

        const originalText = button.textContent || '';
        const setBusy = (text) => {
          button.disabled = true;
          if (text) {
            button.textContent = text;
          }
        };
        const resetButton = () => {
          button.disabled = false;
          button.textContent = originalText;
        };

        try {
          if (action === 'delete') {
            if (!window.confirm(`Delete visit history for ${ip}?`)) {
              return;
            }
            setBusy('Deletingâ€¦');
            const res = await fetch(`/admin/visitors/${encodeURIComponent(ip)}`, {
              method: 'DELETE',
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
              throw new Error(data.message || 'Unable to delete visitor history.');
            }
            await refreshPresenceData();
            return;
          }

          if (action === 'ban') {
            if (!window.confirm(`Ban ${ip}? They will be blocked from the site.`)) {
              return;
            }
            setBusy('Banningâ€¦');
            const res = await fetch('/admin/visitors/banned', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ ip }),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
              throw new Error(data.message || 'Unable to ban IP address.');
            }
            await refreshPresenceData();
            return;
          }

          if (action === 'unban') {
            setBusy('Unbanningâ€¦');
            const res = await fetch(`/admin/visitors/banned/${encodeURIComponent(ip)}`, {
              method: 'DELETE',
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
              throw new Error(data.message || 'Unable to unban IP address.');
            }
            await refreshPresenceData();
            return;
          }
        } catch (error) {
          console.error('Visitor history action failed.', error);
          const message = error && error.message ? error.message : 'Action failed';
          button.disabled = false;
          button.textContent = message;
          window.setTimeout(() => {
            if (!document.body.contains(button)) {
              return;
            }
            resetButton();
          }, 2400);
        }
      });
    }

    async function loadBookings() {
      bookingsTable.className = 'empty-state';
      bookingsTable.textContent = 'Loading bookingsâ€¦';
      setSummaryText(bookingsSummaryHighlight, 'Loading bookingsâ€¦');
      try {
        const res = await fetch('/api/bookings');
        if (!res.ok) throw new Error('Unable to fetch bookings');
        const data = await res.json();
        bookingsCache = Array.isArray(data.bookings) ? data.bookings : [];
        updateBookingSummary();
        renderBookings();
      } catch (error) {
        bookingsTable.textContent = error.message || 'Failed to load bookings';
        setSummaryText(bookingsSummaryHighlight, error.message || 'Unable to load bookings.');
      }
    }

    function renderBookings() {
      updateBookingSummary();
      if (!bookingsCache.length) {
        bookingsTable.className = 'empty-state';
        bookingsTable.textContent = 'No bookings recorded yet.';
        return;
      }

      bookingsTable.className = 'table-scroll';
      bookingsTable.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Customer</th>
              <th>Contact</th>
              <th>Service Info</th>
              <th>Appointment</th>
              <th>Photos</th>
              <th style="width: 180px;">Actions</th>
            </tr>
          </thead>
          <tbody>
            ${bookingsCache
              .map((booking) => {
                const name = escapeHtml(booking.name || 'â€”');
                const location = escapeHtml(booking.location || '');
                const phone = escapeHtml(booking.phone || 'â€”');
                const email = escapeHtml(booking.email || 'â€”');
                const time = escapeHtml(booking.time || 'â€”');
                const serviceType = escapeHtml(booking.service_type || '');
                const created = formatDate(booking.created_at);
                const id = escapeHtml(booking.id || '');
                const photos = booking.photos || [];
                
                const serviceLabel = serviceType === 'one-off' ? 'One-off Cut' : 
                                   serviceType === 'regular' ? 'Regular Cuts' : 
                                   'Not specified';
                
                const photosHtml = photos.length > 0 
                  ? `<button type="button" class="primary" data-action="view-photos" data-id="${id}" style="font-size: 0.85rem; padding: 6px 12px;">${photos.length} photo${photos.length > 1 ? 's' : ''}</button>`
                  : '<span class="cell-muted">None</span>';
                
                return `
                  <tr>
                    <td>
                      <div class="cell-main">
                        <strong>${name}</strong>
                        <span class="cell-muted">${location || 'No location set'}</span>
                      </div>
                    </td>
                    <td>
                      <div class="cell-main">
                        <span>${phone}</span>
                        <span class="cell-muted">${email}</span>
                      </div>
                    </td>
                    <td>
                      <div class="cell-main">
                        <span class="chip" style="background: ${serviceType === 'regular' ? '#30c3a6' : '#ffd166'}; color: #000;">${serviceLabel}</span>
                        <span class="cell-muted">${location ? 'Area: ' + location : ''}</span>
                      </div>
                    </td>
                    <td>
                      <div class="cell-main">
                        <span class="chip">${time}</span>
                        <span class="cell-muted">Added ${created}</span>
                      </div>
                    </td>
                    <td>
                      ${photosHtml}
                    </td>
                    <td>
                      <div class="panel-actions">
                        <button type="button" data-action="edit" data-id="${id}" class="primary">Edit</button>
                        <button type="button" data-action="delete" data-id="${id}" class="danger">Delete</button>
                      </div>
                    </td>
                  </tr>`;
              })
              .join('')}
          </tbody>
        </table>
      `;

      bookingsTable.querySelectorAll('[data-action="view-photos"]').forEach((button) => {
        button.addEventListener('click', () => viewBookingPhotos(button.dataset.id));
      });
      bookingsTable.querySelectorAll('[data-action="edit"]').forEach((button) => {
        button.addEventListener('click', () => openBookingDialog(button.dataset.id));
      });
      bookingsTable.querySelectorAll('[data-action="delete"]').forEach((button) => {
        button.addEventListener('click', () => deleteBooking(button.dataset.id));
      });
    }

    function viewBookingPhotos(id) {
      if (!id) return;
      const booking = bookingsCache.find(b => b.id === id);
      if (!booking || !booking.photos || booking.photos.length === 0) {
        alert('No photos available for this booking.');
        return;
      }

      const photosHtml = booking.photos.map((photo, index) => `
        <div style="margin-bottom: 20px;">
          <p style="margin-bottom: 8px; font-weight: 600; color: var(--text-muted);">Photo ${index + 1}: ${escapeHtml(photo.name || 'Image')}</p>
          <img src="${photo.data}" alt="Garden photo ${index + 1}" style="max-width: 100%; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
        </div>
      `).join('');

      const modal = document.createElement('div');
      modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 10000; padding: 20px; overflow-y: auto;';
      modal.innerHTML = `
        <div style="background: var(--panel-bg); border: 1px solid var(--panel-border); border-radius: 18px; padding: 24px; max-width: 800px; width: 100%; max-height: 90vh; overflow-y: auto; backdrop-filter: blur(16px);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--text-primary);">Garden Photos - ${escapeHtml(booking.name || 'Customer')}</h3>
            <button type="button" style="background: var(--danger); color: white; border: none; border-radius: 8px; padding: 8px 16px; cursor: pointer; font-weight: 600;" onclick="this.closest('div').parentElement.parentElement.remove()">Close</button>
          </div>
          <div>${photosHtml}</div>
        </div>
      `;
      document.body.appendChild(modal);
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }

    async function deleteBooking(id) {
      if (!id) return;
      const confirmed = window.confirm('Delete this booking?');
      if (!confirmed) return;
      try {
        const res = await fetch(`/api/bookings/${encodeURIComponent(id)}`, {
          method: 'DELETE',
        });
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          throw new Error(data.message || 'Unable to delete booking');
        }
        await loadBookings();
        await loadAvailability();
      } catch (error) {
        alert(error.message || 'Unable to delete booking');
      }
    }

    function openBookingDialog(id) {
      const booking = bookingsCache.find((item) => item.id === id);
      if (!booking) return;

      bookingEditForm.dataset.id = id;
      bookingNameInput.value = booking.name || '';
      bookingEmailInput.value = booking.email || '';
      bookingPhoneInput.value = booking.phone || '';
      bookingLocationInput.value = booking.location || '';
      bookingTimeInput.value = booking.time || '';
      bookingFormFeedback.classList.remove('visible');
      bookingFormFeedback.textContent = '';
      showDialog(bookingDialog);
      setTimeout(() => bookingNameInput.focus(), 50);
    }

    bookingEditForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      const id = bookingEditForm.dataset.id;
      if (!id) return;
      bookingFormFeedback.classList.remove('visible');
      bookingFormFeedback.textContent = '';

      const payload = {
        name: bookingNameInput.value.trim(),
        email: bookingEmailInput.value.trim(),
        phone: bookingPhoneInput.value.trim(),
        location: bookingLocationInput.value,
        time: bookingTimeInput.value.trim(),
      };

      try {
        const res = await fetch(`/api/bookings/${encodeURIComponent(id)}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to update booking');
        }
        closeDialog(bookingDialog);
        await loadBookings();
        await loadAvailability();
      } catch (error) {
        bookingFormFeedback.textContent = error.message || 'Unable to update booking.';
        bookingFormFeedback.classList.add('visible');
      }
    });

    closeBookingDialogBtn.addEventListener('click', () => closeDialog(bookingDialog));

    async function loadAvailability() {
      availabilityList.className = 'empty-state';
      availabilityList.textContent = 'Loading availabilityâ€¦';
      setSummaryText(availabilitySummaryHighlight, 'Loading availability slotsâ€¦');
      try {
        const res = await fetch('/availability');
        if (!res.ok) throw new Error('Unable to fetch availability');
        const slots = await res.json();
        availabilityCache = Array.isArray(slots) ? slots : [];
        renderAvailability(availabilityCache);
      } catch (error) {
        availabilityList.textContent = error.message || 'Failed to load availability';
        availabilityCache = [];
        setSummaryText(availabilitySummaryHighlight, error.message || 'Unable to load availability slots.');
      }
    }

    function renderAvailability(slots) {
      updateAvailabilitySummary(slots);
      if (!slots.length) {
        availabilityList.className = 'empty-state';
        availabilityList.textContent = 'No free slots available.';
        return;
      }

      availabilityList.className = 'availability-list';
      availabilityList.innerHTML = slots
        .map((slot) => `
          <div class="availability-item">
            <span>${escapeHtml(slot)}</span>
            <button type="button" class="danger" data-slot="${escapeHtml(slot)}">Remove</button>
          </div>
        `)
        .join('');

      availabilityList.querySelectorAll('[data-slot]').forEach((button) => {
        button.addEventListener('click', () => removeAvailability(button.dataset.slot));
      });
    }

    async function removeAvailability(slot) {
      if (!slot) return;
      const confirmed = window.confirm(`Remove slot "${slot}"?`);
      if (!confirmed) return;
      try {
        const res = await fetch('/availability', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ slot }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to remove slot');
        }
        await loadAvailability();
      } catch (error) {
        alert(error.message || 'Unable to remove slot');
      }
    }

    availabilityForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      const formData = new FormData(availabilityForm);
      const date = (formData.get('date') || '').toString();
      const time = (formData.get('time') || '').toString();
      if (!date || !time) {
        alert('Please choose both a date and time for the slot.');
        return;
      }
      try {
        await createAvailabilitySlot(date, time);
        availabilityForm.reset();
        if (availabilityDateInput) {
          availabilityDateInput.dispatchEvent(new Event('input', { bubbles: true }));
        }
        if (availabilityTimeInput) {
          availabilityTimeInput.dispatchEvent(new Event('input', { bubbles: true }));
        }
        await loadAvailability();
      } catch (error) {
        alert(error.message || 'Unable to add slot');
      }
    });

    if (availabilityDateInput) {
      availabilityDateInput.addEventListener('input', () => {
        markActiveQuickButtons(quickDateShortcuts, 'date', availabilityDateInput.value);
      });
    }

    if (availabilityTimeInput) {
      availabilityTimeInput.addEventListener('input', () => {
        updateQuickTimeButtons(availabilityTimeInput.value);
      });
    }

    if (quickTimeShortcuts && availabilityTimeInput) {
      quickTimeShortcuts.querySelectorAll('button').forEach((button) => {
        button.addEventListener('click', () => {
          const value = button.dataset.quickTime || '';
          if (!value) return;
          availabilityTimeInput.value = value;
          availabilityTimeInput.dispatchEvent(new Event('input', { bubbles: true }));
          updateQuickTimeButtons(value);
        });
      });
    }

    if (quickDateShortcuts && availabilityDateInput) {
      renderQuickDateButtons();
    }

    if (availabilityTimeInput) {
      updateQuickTimeButtons(availabilityTimeInput.value);
    }

    if (autoNextWeekSlotsBtn) {
      autoNextWeekSlotsBtn.addEventListener('click', async () => {
        if (autoNextWeekSlotsBtn.disabled) return;
        clearAutoScheduleFeedback();
        updateAutoScheduleFeedback('Preparing next week evening trioâ€¦');
        autoNextWeekSlotsBtn.disabled = true;
        try {
          const targets = computeNextWeekEveningSlots();
          if (!targets.length) {
            updateAutoScheduleFeedback('No suitable Monday/Wednesday evening slots were found.', false);
            return;
          }
          const existing = new Set(Array.isArray(availabilityCache) ? availabilityCache : []);
          const toCreate = targets.filter((slot) => !existing.has(`${slot.date} ${slot.time}`));
          if (!toCreate.length) {
            updateAutoScheduleFeedback('Those Monday and Wednesday evening slots are already published.', true);
            return;
          }
          const skippedCount = targets.length - toCreate.length;
          const created = [];
          for (const slot of toCreate) {
            await createAvailabilitySlot(slot.date, slot.time);
            existing.add(`${slot.date} ${slot.time}`);
            created.push(slot);
          }
          await loadAvailability();
          const summary = created.map((slot) => formatSlotDescription(slot.date, slot.time)).join(', ');
          let message = `Added ${created.length} slot${created.length === 1 ? '' : 's'}: ${summary}.`;
          if (skippedCount > 0) {
            message += ` Skipped ${skippedCount} existing slot${skippedCount === 1 ? '' : 's'}.`;
          }
          updateAutoScheduleFeedback(message, true);
        } catch (error) {
          updateAutoScheduleFeedback(error.message || 'Unable to add automatic slots.');
        } finally {
          autoNextWeekSlotsBtn.disabled = false;
        }
      });
    }

    if (customerSlotForm) {
      customerSlotForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        customerSlotFeedback?.classList.remove('visible', 'error', 'success');
        const formData = new FormData(customerSlotForm);
        const date = (formData.get('date') || '').toString();
        const time = (formData.get('time') || '').toString();
        if (!date || !time) {
          customerSlotFeedback.textContent = 'Please choose both a date and time.';
          customerSlotFeedback.classList.add('visible', 'error');
          return;
        }
        try {
          await addCustomerSlot(date, time);
          customerSlotFeedback.textContent = 'Customer slot added.';
          customerSlotFeedback.classList.add('visible', 'success');
          customerSlotForm.reset();
          await loadCustomerSlots();
        } catch (error) {
          customerSlotFeedback.textContent = error.message || 'Unable to add slot.';
          customerSlotFeedback.classList.add('visible', 'error');
        }
      });
    }

    if (customerAccessForm) {
      customerAccessForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        customerAccessFeedback?.classList.remove('visible', 'error', 'success');
        const accessCode = customerAccessCodeInput ? customerAccessCodeInput.value.trim() : '';
        if (!accessCode) {
          customerAccessFeedback.textContent = 'Please enter an access code to save.';
          customerAccessFeedback.classList.add('visible', 'error');
          return;
        }
        try {
          await saveCustomerAccessCode(accessCode);
          customerAccessFeedback.textContent = 'Access code updated.';
          customerAccessFeedback.classList.add('visible', 'success');
        } catch (error) {
          customerAccessFeedback.textContent = error.message || 'Unable to save access code.';
          customerAccessFeedback.classList.add('visible', 'error');
        }
      });
    }

    if (refreshCustomerSlotsBtn) {
      refreshCustomerSlotsBtn.addEventListener('click', () => {
        loadCustomerAccessCode();
        loadCustomerSlots();
      });
    }

    async function loadContacts() {
      contactsTable.className = 'empty-state';
      contactsTable.textContent = 'Loading enquiriesâ€¦';
      setSummaryText(contactsSummaryHighlight, 'Loading enquiriesâ€¦');
      try {
        const res = await fetch('/api/contacts');
        if (!res.ok) throw new Error('Unable to fetch enquiries');
        const data = await res.json();
        contactsCache = Array.isArray(data.contacts) ? data.contacts : [];
        renderContacts();
      } catch (error) {
        contactsTable.textContent = error.message || 'Failed to load enquiries';
        contactsCache = [];
        setSummaryText(contactsSummaryHighlight, error.message || 'Unable to load contact enquiries.');
      }
    }

    function renderContacts() {
      updateContactSummary();
      if (!contactsCache.length) {
        contactsTable.className = 'empty-state';
        contactsTable.textContent = 'No enquiries yet.';
        return;
      }

      contactsTable.className = 'table-scroll';
      contactsTable.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>From</th>
              <th>Contact</th>
              <th>Received</th>
              <th style="width: 180px;">Actions</th>
            </tr>
          </thead>
          <tbody>
            ${contactsCache
              .map((contact) => {
                const name = escapeHtml(contact.name || 'â€”');
                const phone = escapeHtml(contact.phone || 'â€”');
                const email = escapeHtml(contact.email || 'â€”');
                const status = escapeHtml(contact.status || 'new');
                const created = formatDate(contact.created_at);
                const id = escapeHtml(contact.id || '');
                return `
                  <tr>
                    <td>
                      <div class="cell-main">
                        <strong>${name}</strong>
                        <span class="badge ${status === 'new' ? 'new' : 'done'}">${status === 'new' ? 'New' : 'Reviewed'}</span>
                      </div>
                    </td>
                    <td>
                      <div class="cell-main">
                        <span>${phone}</span>
                        <span class="cell-muted">${email}</span>
                      </div>
                    </td>
                    <td>
                      <div class="cell-main">
                        <span>${created}</span>
                      </div>
                    </td>
                    <td>
                      <div class="panel-actions">
                        <button type="button" data-action="view" data-id="${id}" class="primary">View</button>
                        <button type="button" data-action="remove" data-id="${id}" class="danger">Delete</button>
                      </div>
                    </td>
                  </tr>`;
              })
              .join('')}
          </tbody>
        </table>
      `;

      contactsTable.querySelectorAll('[data-action="view"]').forEach((button) => {
        button.addEventListener('click', () => openContactDialog(button.dataset.id));
      });
      contactsTable.querySelectorAll('[data-action="remove"]').forEach((button) => {
        button.addEventListener('click', () => deleteContact(button.dataset.id));
      });
    }

    async function loadReviews() {
      if (!reviewsTable) return;
      reviewsTable.className = 'empty-state';
      reviewsTable.textContent = 'Loading testimonialsâ€¦';
      setSummaryText(reviewsSummaryHighlight, 'Loading testimonialsâ€¦');
      try {
        const res = await fetch('/api/reviews');
        if (!res.ok) throw new Error('Unable to fetch testimonials');
        const data = await res.json();
        reviewsCache = Array.isArray(data.reviews) ? data.reviews : [];
        renderReviews();
      } catch (error) {
        reviewsCache = [];
        reviewsTable.className = 'empty-state';
        reviewsTable.textContent = error.message || 'Failed to load testimonials.';
        setSummaryText(reviewsSummaryHighlight, error.message || 'Unable to load testimonials.');
      }
    }

    function renderReviews() {
      updateReviewsSummary();
      if (!reviewsTable) return;
      if (!reviewsCache.length) {
        reviewsTable.className = 'empty-state';
        reviewsTable.textContent = 'No testimonials published yet.';
        return;
      }

      reviewsTable.className = 'table-scroll';
      reviewsTable.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Testimonial</th>
              <th>Client</th>
              <th style="width: 180px;">Actions</th>
            </tr>
          </thead>
          <tbody>
            ${reviewsCache
              .map((review) => {
                const id = escapeHtml(review.id || '');
                const quote = escapeHtml(review.quote || '');
                const author = escapeHtml(review.author || 'Anonymous');
                const location = escapeHtml(
                  review.location && review.location.trim() ? review.location : 'Location not provided'
                );
                const timestamp = review.updated_at || review.created_at;
                const meta = review.updated_at ? 'Updated' : 'Added';
                const metaDate = formatDate(timestamp);
                return `
                  <tr>
                    <td>
                      <div class="cell-main">
                        <span>&ldquo;${quote || 'No quote provided'}&rdquo;</span>
                        <span class="cell-muted">${meta} ${metaDate}</span>
                      </div>
                    </td>
                    <td>
                      <div class="cell-main">
                        <strong>${author}</strong>
                        <span class="cell-muted">${location}</span>
                      </div>
                    </td>
                    <td>
                      <div class="panel-actions">
                        <button type="button" data-action="edit" data-id="${id}" class="primary">Edit</button>
                        <button type="button" data-action="delete" data-id="${id}" class="danger">Delete</button>
                      </div>
                    </td>
                  </tr>`;
              })
              .join('')}
          </tbody>
        </table>
      `;

      reviewsTable.querySelectorAll('[data-action="edit"]').forEach((button) => {
        button.addEventListener('click', () => {
          const id = button.dataset.id || '';
          const review = reviewsCache.find((item) => item && item.id === id);
          if (review) {
            openReviewDialog('edit', review);
          }
        });
      });

      reviewsTable.querySelectorAll('[data-action="delete"]').forEach((button) => {
        button.addEventListener('click', async () => {
          const id = button.dataset.id || '';
          if (!id) return;
          const confirmed = window.confirm('Delete this testimonial?');
          if (!confirmed) return;
          button.disabled = true;
          try {
            const res = await fetch(`/api/reviews/${encodeURIComponent(id)}`, { method: 'DELETE' });
            if (!res.ok) {
              const data = await res.json().catch(() => ({}));
              throw new Error(data.message || 'Unable to delete testimonial.');
            }
            await loadReviews();
          } catch (error) {
            alert(error.message || 'Unable to delete testimonial.');
          } finally {
            button.disabled = false;
          }
        });
      });
    }

    function openReviewDialog(mode = 'create', review = null) {
      if (!reviewDialog || !reviewForm) return;
      reviewForm.reset();
      reviewForm.dataset.mode = mode;
      if (reviewFormFeedback) {
        reviewFormFeedback.textContent = '';
        reviewFormFeedback.classList.remove('visible', 'success');
      }
      if (reviewDialogTitle) {
        reviewDialogTitle.textContent = mode === 'edit' ? 'Edit testimonial' : 'Add testimonial';
      }
      if (reviewDialogSubtitle) {
        reviewDialogSubtitle.textContent =
          mode === 'edit'
            ? 'Update the quote shown on your homepage.'
            : 'Publish new words from your customers on the homepage.';
      }
      if (mode === 'edit' && review) {
        if (reviewAuthorInput) reviewAuthorInput.value = review.author || '';
        if (reviewLocationInput) reviewLocationInput.value = review.location || '';
        if (reviewTextInput) reviewTextInput.value = review.quote || '';
        if (reviewIdInput) reviewIdInput.value = review.id || '';
      } else {
        if (reviewAuthorInput) reviewAuthorInput.value = '';
        if (reviewLocationInput) reviewLocationInput.value = '';
        if (reviewTextInput) reviewTextInput.value = '';
        if (reviewIdInput) reviewIdInput.value = '';
      }

      showDialog(reviewDialog);
      requestAnimationFrame(() => {
        if (reviewAuthorInput) {
          reviewAuthorInput.focus();
        }
      });
    }

    if (addReviewBtn) {
      addReviewBtn.addEventListener('click', () => openReviewDialog('create'));
    }

    if (closeReviewDialogBtn) {
      closeReviewDialogBtn.addEventListener('click', () => closeDialog(reviewDialog));
    }

    if (reviewForm) {
      reviewForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!reviewAuthorInput || !reviewTextInput) {
          return;
        }

        const quote = reviewTextInput.value.trim();
        const author = reviewAuthorInput.value.trim();
        const location = reviewLocationInput ? reviewLocationInput.value.trim() : '';

        if (!quote || !author) {
          reviewForm.reportValidity();
          return;
        }

        const mode = reviewForm.dataset.mode === 'edit' ? 'edit' : 'create';
        const reviewId = reviewIdInput ? reviewIdInput.value.trim() : '';

        if (reviewFormFeedback) {
          reviewFormFeedback.textContent = '';
          reviewFormFeedback.classList.remove('visible', 'success');
        }
        if (reviewSubmitButton) {
          reviewSubmitButton.disabled = true;
        }

        try {
          const endpoint = mode === 'edit' && reviewId
            ? `/api/reviews/${encodeURIComponent(reviewId)}`
            : '/api/reviews';
          const res = await fetch(endpoint, {
            method: mode === 'edit' ? 'PUT' : 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ quote, author, location }),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) {
            throw new Error(data.message || 'Unable to save testimonial.');
          }
          closeDialog(reviewDialog);
          await loadReviews();
        } catch (error) {
          if (reviewFormFeedback) {
            reviewFormFeedback.textContent = error.message || 'Unable to save testimonial.';
            reviewFormFeedback.classList.add('visible');
            reviewFormFeedback.classList.remove('success');
          }
        } finally {
          if (reviewSubmitButton) {
            reviewSubmitButton.disabled = false;
          }
        }
      });
    }

    function openContactDialog(id) {
      const contact = contactsCache.find((item) => item.id === id);
      if (!contact) return;
      contactDialog.dataset.id = id;
      contactDialogMeta.textContent = `${contact.email || 'â€”'} Â· ${contact.phone || 'â€”'} Â· ${formatDate(contact.created_at)}`;
      contactDialogMessage.textContent = contact.enquiry || '';
      contactDialogFeedback.classList.remove('visible');
      contactDialogFeedback.textContent = '';
      toggleContactStatusBtn.textContent = contact.status === 'new' ? 'Mark as reviewed' : 'Mark as new';
      showDialog(contactDialog);
    }

    async function updateContactStatus(id, status) {
      try {
        const res = await fetch(`/api/contacts/${encodeURIComponent(id)}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to update enquiry');
        }
        await loadContacts();
        const updated = contactsCache.find((item) => item.id === id);
        if (updated) {
          toggleContactStatusBtn.textContent = updated.status === 'new' ? 'Mark as reviewed' : 'Mark as new';
        }
      } catch (error) {
        contactDialogFeedback.textContent = error.message || 'Unable to update enquiry.';
        contactDialogFeedback.classList.add('visible');
      }
    }

    async function deleteContact(id) {
      if (!id) return;
      const confirmed = window.confirm('Delete this enquiry?');
      if (!confirmed) return;
      try {
        const res = await fetch(`/api/contacts/${encodeURIComponent(id)}`, {
          method: 'DELETE',
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to delete enquiry');
        }
        await loadContacts();
      } catch (error) {
        alert(error.message || 'Unable to delete enquiry');
      }
    }

    toggleContactStatusBtn.addEventListener('click', () => {
      const id = contactDialog.dataset.id;
      if (!id) return;
      const contact = contactsCache.find((item) => item.id === id);
      if (!contact) return;
      const nextStatus = contact.status === 'new' ? 'reviewed' : 'new';
      updateContactStatus(id, nextStatus);
    });

    deleteContactBtn.addEventListener('click', () => {
      const id = contactDialog.dataset.id;
      if (!id) return;
      deleteContact(id).then(() => closeDialog(contactDialog));
    });

    function truncateText(value, limit = 90) {
      if (typeof value !== 'string') return '';
      if (value.length <= limit) return value;
      return `${value.slice(0, limit - 1)}â€¦`;
    }

    function formatRelativeTime(value) {
      if (!value) return 'Just now';
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return value;
      const diffSeconds = (Date.now() - date.getTime()) / 1000;
      if (diffSeconds < 60) return 'Just now';
      if (diffSeconds < 3600) return `${Math.floor(diffSeconds / 60)}m ago`;
      if (diffSeconds < 86400) return `${Math.floor(diffSeconds / 3600)}h ago`;
      return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
    }

    function formatChatTimestamp(value) {
      if (!value) return '';
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return value;
      const datePart = date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
      const timePart = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      return `${datePart} ${timePart}`;
    }

    function updateChatStatusIndicator(online) {
      chatOnline = Boolean(online);
      if (chatStatusIndicator) {
        chatStatusIndicator.textContent = chatOnline ? 'Chat online' : 'Chat offline';
        chatStatusIndicator.classList.toggle('offline', !chatOnline);
      }
      if (toggleChatStatusBtn) {
        toggleChatStatusBtn.textContent = chatOnline ? 'Go offline' : 'Go online';
      }
      const disableReply = !selectedChatSessionId;
      if (chatReplyForm) {
        chatReplyForm.classList.toggle('disabled', disableReply);
      }
      if (chatReplyInput) {
        chatReplyInput.disabled = disableReply;
        if (!selectedChatSessionId) {
          chatReplyInput.value = '';
        }
        chatReplyInput.placeholder = selectedChatSessionId
          ? (chatOnline ? 'Write a replyâ€¦' : 'Reply to this visitor (chat is offline)')
          : 'Select a conversation to reply';
      }
      if (chatReplySubmit) {
        chatReplySubmit.disabled = disableReply;
      }
      if (chatReplyStatus) {
        chatReplyStatus.textContent = chatOnline
          ? ''
          : 'Website visitors currently see an offline notice.';
      }

      updateChatSummary();
    }

    function renderChatSessions() {
      if (!chatSessionsContainer) return;
      updateChatSummary();
      if (!chatSessionsCache.length) {
        chatSessionsContainer.className = 'chat-sessions-empty';
        chatSessionsContainer.textContent = chatOnline
          ? 'No live conversations yet.'
          : 'Chat is offline. Visitors cannot start new chats.';
        return;
      }

      chatSessionsContainer.className = 'chat-session-scroll';
      chatSessionsContainer.innerHTML = '';

      chatSessionsCache.forEach((session) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'chat-session';
        if (session.session_id === selectedChatSessionId) {
          button.classList.add('active');
        }
        button.dataset.sessionId = session.session_id;

        const title = document.createElement('div');
        title.className = 'chat-session-title';
        const label = document.createElement('span');
        label.textContent = session.visitor && session.visitor.location
          ? session.visitor.location
          : 'Website visitor';
        title.appendChild(label);
        const lastSeen = document.createElement('span');
        lastSeen.textContent = formatRelativeTime(session.last_seen);
        title.appendChild(lastSeen);
        button.appendChild(title);

        const preview = document.createElement('div');
        preview.className = 'chat-session-preview';
        preview.textContent = session.last_message
          ? truncateText(session.last_message, 90)
          : 'No messages yet.';
        button.appendChild(preview);

        const meta = document.createElement('div');
        meta.className = 'chat-session-meta';
        if (session.visitor && session.visitor.last_page) {
          const page = document.createElement('span');
          page.textContent = `Page: ${session.visitor.last_page}`;
          meta.appendChild(page);
        }
        if (session.visitor && session.visitor.ip) {
          const ip = document.createElement('span');
          ip.textContent = `IP ${session.visitor.ip}`;
          meta.appendChild(ip);
        }
        const total = document.createElement('span');
        total.textContent = `${session.message_count || 0} messages`;
        meta.appendChild(total);
        if (session.unread_from_visitor) {
          const unread = document.createElement('span');
          unread.className = 'badge-unread';
          unread.textContent = `${session.unread_from_visitor} new`;
          meta.appendChild(unread);
        }

        const closeButton = document.createElement('button');
        closeButton.type = 'button';
        closeButton.className = 'chat-session-close';
        closeButton.textContent = 'Close chat';
        closeButton.dataset.sessionClose = 'true';
        closeButton.dataset.sessionId = session.session_id || '';
        meta.appendChild(closeButton);

        button.appendChild(meta);
        chatSessionsContainer.appendChild(button);
      });
    }

    function stopChatPolling() {
      if (chatMessagePollHandle) {
        clearInterval(chatMessagePollHandle);
        chatMessagePollHandle = null;
      }
    }

    function clearChatThread() {
      selectedChatSessionId = null;
      chatLastMessageId = 0;
      stopChatPolling();
      if (chatThread) {
        chatThread.hidden = true;
      }
      if (chatThreadMessages) {
        chatThreadMessages.innerHTML = '';
      }
      if (chatThreadMeta) {
        chatThreadMeta.textContent = '';
      }
      if (chatThreadEmpty) {
        chatThreadEmpty.style.display = 'flex';
      }
      updateChatStatusIndicator(chatOnline);
    }

    function appendChatThreadMessage(message) {
      if (!message || !chatThreadMessages) return;
      const messageId = Number(message.id);
      if (Number.isFinite(messageId) && messageId <= chatLastMessageId) {
        return;
      }
      if (Number.isFinite(messageId)) {
        chatLastMessageId = messageId;
      }

      const sender = typeof message.sender === 'string' ? message.sender : 'visitor';
      const isAutopilot = sender === 'autopilot';
      const isAdminMessage = sender === 'admin' || isAutopilot;

      const wrapper = document.createElement('div');
      wrapper.className = `thread-message ${isAdminMessage ? 'from-admin' : 'from-visitor'}`;
      if (isAutopilot) {
        wrapper.classList.add('autopilot');
      }

      const bubble = document.createElement('div');
      bubble.className = 'thread-message-bubble';
      bubble.textContent = message.text || '';
      wrapper.appendChild(bubble);

      const meta = document.createElement('span');
      meta.className = 'thread-message-meta';
      const senderLabel = isAutopilot ? 'Autopilot' : isAdminMessage ? 'You' : 'Visitor';
      meta.textContent = `${senderLabel} â€¢ ${formatChatTimestamp(message.timestamp)}`;
      wrapper.appendChild(meta);

      chatThreadMessages.appendChild(wrapper);
      chatThreadMessages.scrollTop = chatThreadMessages.scrollHeight;
    }

    async function loadChatSessions(silent = false) {
      if (!chatSessionsContainer) return;
      if (chatSessionsLoading) {
        if (!silent) {
          try {
            await chatSessionsLoading;
          } catch (error) {
            console.error(error);
          }
        }
        return chatSessionsLoading;
      }

      if (!silent) {
        chatSessionsContainer.className = 'chat-sessions-empty';
        chatSessionsContainer.textContent = 'Loading conversationsâ€¦';
        setSummaryText(chatSummaryHighlight, 'Loading conversationsâ€¦');
      }

      const loader = (async () => {
        try {
          const res = await fetch('/admin/chat/sessions');
          if (!res.ok) {
            throw new Error('Unable to load conversations.');
          }
          const data = await res.json();
          chatSessionsCache = Array.isArray(data.sessions) ? data.sessions : [];
          chatOnline = typeof data.online === 'boolean' ? data.online : true;
          if (selectedChatSessionId) {
            const stillExists = chatSessionsCache.some((session) => session.session_id === selectedChatSessionId);
            if (!stillExists) {
              clearChatThread();
            }
          }
          updateChatStatusIndicator(chatOnline);
          renderChatSessions();
        } catch (error) {
          if (!silent) {
            chatSessionsContainer.className = 'chat-sessions-empty';
            chatSessionsContainer.textContent = error.message || 'Unable to load conversations.';
            chatSessionsCache = [];
            setSummaryText(chatSummaryHighlight, error.message || 'Unable to load conversations right now.');
            updateChatAttentionIndicator(0);
          } else {
            console.error(error);
          }
        } finally {
          chatSessionsLoading = null;
        }
      })();

      chatSessionsLoading = loader;
      if (silent) {
        loader.catch(() => {});
        return loader;
      }
      return loader;
    }

    function startChatPolling() {
      stopChatPolling();
      chatMessagePollHandle = setInterval(() => {
        loadChatMessages(false);
      }, CHAT_POLL_INTERVAL);
    }

    async function loadChatMessages(reset = false) {
      if (!selectedChatSessionId) return;
      const params = new URLSearchParams();
      if (!reset && chatLastMessageId) {
        params.set('after', String(chatLastMessageId));
      }
      const query = params.toString();
      const url = query
        ? `/admin/chat/messages/${encodeURIComponent(selectedChatSessionId)}?${query}`
        : `/admin/chat/messages/${encodeURIComponent(selectedChatSessionId)}`;

      try {
        const res = await fetch(url);
        if (res.status === 404) {
          await loadChatSessions();
          clearChatThread();
          return;
        }
        if (!res.ok) {
          throw new Error('Unable to fetch conversation.');
        }
        const data = await res.json();
        if (Array.isArray(data.messages)) {
          data.messages.forEach((message) => appendChatThreadMessage(message));
        }
        if (typeof data.online === 'boolean') {
          updateChatStatusIndicator(data.online);
        }
        const session = chatSessionsCache.find((item) => item.session_id === selectedChatSessionId);
        if (session) {
          session.unread_from_visitor = 0;
        }
        renderChatSessions();
      } catch (error) {
        if (chatReplyStatus) {
          chatReplyStatus.textContent = error.message || 'Unable to refresh conversation.';
        }
      }
    }

    async function closeChatSession(sessionId) {
      if (!sessionId) return;
      if (!window.confirm('Close this conversation? It will be removed from the list.')) {
        return;
      }

      try {
        const res = await fetch('/admin/chat/close', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: sessionId }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.message || 'Unable to close chat session.');
        }
        chatSessionsCache = chatSessionsCache.filter((session) => session.session_id !== sessionId);
        if (selectedChatSessionId === sessionId) {
          clearChatThread();
        }
        renderChatSessions();
        await loadChatSessions(true);
      } catch (error) {
        alert(error.message || 'Unable to close chat session.');
      }
    }

    function selectChatSession(sessionId) {
      if (!sessionId) return;
      if (sessionId === selectedChatSessionId) {
        if (chatThreadMessages) {
          chatThreadMessages.scrollTop = chatThreadMessages.scrollHeight;
        }
        return;
      }

      selectedChatSessionId = sessionId;
      chatLastMessageId = 0;
      if (chatThreadEmpty) {
        chatThreadEmpty.style.display = 'none';
      }
      if (chatThread) {
        chatThread.hidden = false;
      }
      if (chatThreadMessages) {
        chatThreadMessages.innerHTML = '';
      }

      const session = chatSessionsCache.find((item) => item.session_id === sessionId);
      if (session) {
        chatThreadTitle.textContent = session.visitor && session.visitor.location
          ? session.visitor.location
          : 'Website visitor';
        const details = [];
        if (session.visitor && session.visitor.last_page) {
          details.push(`Viewing ${session.visitor.last_page}`);
        }
        if (session.visitor && session.visitor.ip) {
          details.push(`IP ${session.visitor.ip}`);
        }
        details.push(`Last active ${formatRelativeTime(session.last_seen)}`);
        chatThreadMeta.textContent = details.join(' â€¢ ');
        session.unread_from_visitor = 0;
      } else if (chatThreadMeta) {
        chatThreadMeta.textContent = '';
      }

      updateChatStatusIndicator(chatOnline);
      renderChatSessions();
      loadChatMessages(true);
      startChatPolling();
    }

    closeContactDialogBtn.addEventListener('click', () => closeDialog(contactDialog));

    if (chatSessionsContainer) {
      chatSessionsContainer.addEventListener('click', (event) => {
        const closeButton = event.target.closest('[data-session-close]');
        if (closeButton && closeButton.dataset.sessionId) {
          event.stopPropagation();
          closeChatSession(closeButton.dataset.sessionId);
          return;
        }
        const target = event.target.closest('.chat-session');
        if (!target || !target.dataset.sessionId) return;
        selectChatSession(target.dataset.sessionId);
      });
    }

    if (refreshChatSessionsBtn) {
      refreshChatSessionsBtn.addEventListener('click', loadChatSessions);
    }

    if (toggleChatStatusBtn) {
      toggleChatStatusBtn.addEventListener('click', async () => {
        toggleChatStatusBtn.disabled = true;
        try {
          const res = await fetch('/admin/chat/status', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ online: !chatOnline }),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) {
            throw new Error(data.message || 'Unable to update chat status.');
          }
          updateChatStatusIndicator(Boolean(data.online));
          await loadChatSessions();
        } catch (error) {
          alert(error.message || 'Unable to update chat status');
        } finally {
          toggleChatStatusBtn.disabled = false;
        }
      });
    }

    if (chatReplyForm) {
      chatReplyForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!selectedChatSessionId || !chatReplyInput) return;
        const message = chatReplyInput.value.trim();
        if (!message) {
          chatReplyInput.focus();
          return;
        }
        if (chatReplyStatus) {
          chatReplyStatus.textContent = '';
        }
        if (chatReplySubmit) {
          chatReplySubmit.disabled = true;
        }
        try {
          const res = await fetch('/admin/chat/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ session_id: selectedChatSessionId, message }),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) {
            throw new Error(data.message || 'Unable to send message.');
          }
          if (chatReplyInput) {
            chatReplyInput.value = '';
            chatReplyInput.focus();
          }
          if (data.entry) {
            appendChatThreadMessage(data.entry);
          }
          await loadChatSessions();
        } catch (error) {
          if (chatReplyStatus) {
            chatReplyStatus.textContent = error.message || 'Unable to send message.';
          }
        } finally {
          if (chatReplySubmit) {
            chatReplySubmit.disabled = !selectedChatSessionId;
          }
        }
      });
    }

    if (autopilotApiKeyInput) {
      autopilotApiKeyInput.addEventListener('input', () => {
        autopilotApiKeyInput.dataset.dirty = 'true';
        const hasValue = autopilotApiKeyInput.value.trim().length > 0;
        const hasExisting = autopilotApiKeyInput.dataset.hasExisting === 'true';
        if (autopilotApiKeyNote) {
          if (hasValue) {
            autopilotApiKeyNote.textContent = 'This key will be saved securely and used for autopilot replies.';
            autopilotApiKeyNote.classList.remove('warning');
          } else if (hasExisting) {
            autopilotApiKeyNote.textContent = 'Leave blank to keep your existing key.';
            autopilotApiKeyNote.classList.remove('warning');
          } else {
            autopilotApiKeyNote.textContent = 'Add your DeepSeek API key so autopilot can reply to visitors.';
            autopilotApiKeyNote.classList.add('warning');
          }
        }
        if (autopilotApiKeyStatus) {
          if (hasValue) {
            autopilotApiKeyStatus.textContent = 'Key ready to save';
            autopilotApiKeyStatus.classList.add('active');
            autopilotApiKeyStatus.classList.remove('offline');
          } else {
            autopilotApiKeyStatus.textContent = hasExisting
              ? 'Key saved for autopilot replies'
              : 'No key saved';
            autopilotApiKeyStatus.classList.toggle('active', hasExisting);
            autopilotApiKeyStatus.classList.toggle('offline', !hasExisting);
          }
        }
      });
    }

    if (openrouterApiKeyInput) {
      openrouterApiKeyInput.addEventListener('input', () => {
        openrouterApiKeyInput.dataset.dirty = 'true';
        const hasValue = openrouterApiKeyInput.value.trim().length > 0;
        const hasExisting = openrouterApiKeyInput.dataset.hasExisting === 'true';
        if (openrouterApiKeyNote) {
          if (hasValue) {
            openrouterApiKeyNote.textContent = 'This key will be saved securely and used for autopilot replies.';
            openrouterApiKeyNote.classList.remove('warning');
          } else if (hasExisting) {
            openrouterApiKeyNote.textContent = 'Leave blank to keep your existing key.';
            openrouterApiKeyNote.classList.remove('warning');
          } else {
            openrouterApiKeyNote.textContent = 'Add your OpenRouter API key so autopilot can reply to visitors.';
            openrouterApiKeyNote.classList.add('warning');
          }
        }
        if (openrouterApiKeyStatus) {
          if (hasValue) {
            openrouterApiKeyStatus.textContent = 'Key ready to save';
            openrouterApiKeyStatus.classList.add('active');
            openrouterApiKeyStatus.classList.remove('offline');
          } else {
            openrouterApiKeyStatus.textContent = hasExisting
              ? 'Key saved for autopilot replies'
              : 'No key saved';
            openrouterApiKeyStatus.classList.toggle('active', hasExisting);
            openrouterApiKeyStatus.classList.toggle('offline', !hasExisting);
          }
        }
      });
    }

    if (weatherApiKeyInput) {
      weatherApiKeyInput.addEventListener('input', () => {
        weatherApiKeyInput.dataset.dirty = 'true';
      });
    }

    if (clearAutopilotApiKeyBtn && autopilotApiKeyInput) {
      clearAutopilotApiKeyBtn.addEventListener('click', () => {
        autopilotApiKeyInput.value = '';
        autopilotApiKeyInput.dataset.dirty = 'true';
        autopilotApiKeyInput.dataset.hasExisting = 'false';
        if (autopilotApiKeyNote) {
          autopilotApiKeyNote.textContent = 'Existing API key will be removed after saving.';
          autopilotApiKeyNote.classList.add('warning');
        }
        if (autopilotApiKeyStatus) {
          autopilotApiKeyStatus.textContent = 'Key will be removed on save';
          autopilotApiKeyStatus.classList.remove('active');
          autopilotApiKeyStatus.classList.add('offline');
        }
        autopilotApiKeyInput.focus();
      });
    }

    if (clearOpenrouterApiKeyBtn && openrouterApiKeyInput) {
      clearOpenrouterApiKeyBtn.addEventListener('click', () => {
        openrouterApiKeyInput.value = '';
        openrouterApiKeyInput.dataset.dirty = 'true';
        openrouterApiKeyInput.dataset.hasExisting = 'false';
        if (openrouterApiKeyNote) {
          openrouterApiKeyNote.textContent = 'Existing API key will be removed after saving.';
          openrouterApiKeyNote.classList.add('warning');
        }
        if (openrouterApiKeyStatus) {
          openrouterApiKeyStatus.textContent = 'Key will be removed on save';
          openrouterApiKeyStatus.classList.remove('active');
          openrouterApiKeyStatus.classList.add('offline');
        }
        openrouterApiKeyInput.focus();
      });
    }

    if (autopilotProviderSelect) {
      autopilotProviderSelect.addEventListener('change', () => {
        autopilotConfig.provider = autopilotProviderSelect.value === 'openrouter' ? 'openrouter' : 'deepseek';
        updateAutopilotSummary();
      });
    }

    autopilotToggleButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const nextEnabled = !autopilotConfig.enabled;
        const businessProfile = autopilotPromptInput
          ? autopilotPromptInput.value.trim()
          : autopilotConfig.business_profile || '';
        const websiteUrl = autopilotWebsiteUrlInput ? autopilotWebsiteUrlInput.value.trim() : '';
        persistAutopilotConfig(applyApiKeyToPayload({
          enabled: nextEnabled,
          business_profile: businessProfile,
          business_website_url: websiteUrl,
          model: autopilotConfig.model,
          temperature: autopilotConfig.temperature,
        }));
      });
    });

    if (autopilotForm) {
      autopilotForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const businessProfile = autopilotPromptInput ? autopilotPromptInput.value.trim() : '';
        const websiteUrl = autopilotWebsiteUrlInput ? autopilotWebsiteUrlInput.value.trim() : '';
        persistAutopilotConfig(
          applyApiKeyToPayload({
            enabled: autopilotConfig.enabled,
            business_profile: businessProfile,
            business_website_url: websiteUrl,
            model: autopilotConfig.model,
            temperature: autopilotConfig.temperature,
          }),
          true
        );
      });
    }

    if (autopilotWebsiteScrapeBtn) {
      autopilotWebsiteScrapeBtn.addEventListener('click', async () => {
        if (autopilotFeedback) {
          autopilotFeedback.classList.remove('visible', 'success');
          autopilotFeedback.textContent = '';
        }
        const url = autopilotWebsiteUrlInput ? autopilotWebsiteUrlInput.value : '';
        setAutopilotBusy(true);
        if (autopilotWebsiteStatus) {
          autopilotWebsiteStatus.textContent = 'Scrapingâ€¦';
          autopilotWebsiteStatus.classList.add('active');
          autopilotWebsiteStatus.classList.remove('offline');
        }
        if (autopilotWebsiteNote) {
          autopilotWebsiteNote.textContent = 'Scraping your siteâ€¦ this can take a moment.';
          autopilotWebsiteNote.classList.remove('warning');
        }
        try {
          await scrapeAutopilotWebsite(url);
          if (autopilotFeedback) {
            autopilotFeedback.textContent = 'Website scraped and saved.';
            autopilotFeedback.classList.add('visible', 'success');
          }
          if (autopilotWebsiteNote) {
            autopilotWebsiteNote.textContent =
              'Tip: use your homepage URL. We\'ll crawl internal pages on the same domain and skip any /admin areas. (Localhost/private URLs are blocked unless enabled on the server.)';
            autopilotWebsiteNote.classList.remove('warning');
          }
        } catch (error) {
          const message = (error && error.message) ? String(error.message) : 'Unable to scrape website.';
          if (autopilotWebsiteStatus) {
            autopilotWebsiteStatus.textContent = message.length <= 26 ? message : 'Scrape failed';
            autopilotWebsiteStatus.classList.remove('active');
            autopilotWebsiteStatus.classList.add('offline');
          }
          if (autopilotWebsiteNote) {
            autopilotWebsiteNote.textContent = message;
            autopilotWebsiteNote.classList.add('warning');
          }
          if (autopilotFeedback) {
            autopilotFeedback.textContent = message;
            autopilotFeedback.classList.add('visible');
          }
        } finally {
          setAutopilotBusy(false);
        }
      });
    }

    if (autopilotWebsiteClearBtn) {
      autopilotWebsiteClearBtn.addEventListener('click', async () => {
        if (autopilotFeedback) {
          autopilotFeedback.classList.remove('visible', 'success');
          autopilotFeedback.textContent = '';
        }
        setAutopilotBusy(true);
        try {
          await clearAutopilotWebsiteKnowledge();
          if (autopilotFeedback) {
            autopilotFeedback.textContent = 'Website knowledge cleared.';
            autopilotFeedback.classList.add('visible', 'success');
          }
        } catch (error) {
          if (autopilotFeedback) {
            autopilotFeedback.textContent = error.message || 'Unable to clear website knowledge.';
            autopilotFeedback.classList.add('visible');
          }
        } finally {
          setAutopilotBusy(false);
        }
      });
    }

    if (weatherForm) {
      weatherForm.addEventListener('submit', persistWeatherConfig);
    }

    const smsapiForm = document.getElementById('smsapiForm');
    if (smsapiForm) {
      smsapiForm.addEventListener('submit', persistSmsapiConfig);
    }

    const telnyxForm = document.getElementById('telnyxForm');
    if (telnyxForm) {
      telnyxForm.addEventListener('submit', persistTelnyxConfig);
    }

    const emailConfigForm = document.getElementById('emailConfigForm');
    if (emailConfigForm) {
      emailConfigForm.addEventListener('submit', persistEmailConfig);
    }

    renderAutopilotState();
    updateAutopilotSummary();

    updateChatStatusIndicator(chatOnline);
    renderChatSessions();
    loadChatSessions();

    loadAutopilotConfig();
    loadWeatherConfig();
    loadTelnyxConfig();
    loadSmsapiConfig();
    loadEmailConfig();
    loadSiteImages();

    if (refreshPresenceBtn) {
      refreshPresenceBtn.addEventListener('click', refreshPresenceData);
    }

    if (refreshImagesBtn) {
      refreshImagesBtn.addEventListener('click', () => loadSiteImages());
    }

    if (uploadNewImageBtn) {
      uploadNewImageBtn.addEventListener('click', () => uploadNewImage());
    }

    if (imageLibraryGrid) {
      let gridDragDepth = 0;
      const setGridDropActive = (active) => {
        imageLibraryGrid.classList.toggle('is-drop-target', Boolean(active));
      };

      imageLibraryGrid.addEventListener('dragenter', (event) => {
        event.preventDefault();
        gridDragDepth += 1;
        setGridDropActive(true);
      });
      imageLibraryGrid.addEventListener('dragover', (event) => {
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'copy';
        }
        setGridDropActive(true);
      });
      imageLibraryGrid.addEventListener('dragleave', () => {
        gridDragDepth = Math.max(0, gridDragDepth - 1);
        if (gridDragDepth === 0) {
          setGridDropActive(false);
        }
      });
      imageLibraryGrid.addEventListener('drop', async (event) => {
        event.preventDefault();
        gridDragDepth = 0;
        setGridDropActive(false);
        const file = getDroppedImageFile(event);
        if (!file) {
          showImagesFeedback('Please drop an image file (png/jpg/webp/svg).');
          return;
        }
        await uploadNewImageFile(file);
      });
    }

    // Prevent the browser from navigating away if a file is dropped outside a drop zone.
    document.addEventListener('dragover', (event) => {
      event.preventDefault();
    });
    document.addEventListener('drop', (event) => {
      event.preventDefault();
    });
    refreshBookingsBtn.addEventListener('click', loadBookings);
    refreshAvailabilityBtn.addEventListener('click', loadAvailability);
    refreshContactsBtn.addEventListener('click', loadContacts);
    if (refreshReviewsBtn) {
      refreshReviewsBtn.addEventListener('click', loadReviews);
    }

    // Logout functionality
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
      logoutBtn.addEventListener('click', async () => {
        if (confirm('Are you sure you want to logout?')) {
          try {
            await fetch('/admin/logout', { method: 'POST' });
            window.location.href = '/admin';
          } catch (err) {
            console.error('Logout error:', err);
            window.location.href = '/admin';
          }
        }
      });
    }

    refreshPresenceData();
    loadBookings();
    loadAvailability();
    loadCustomerAccessCode();
    loadCustomerSlots();
    loadContacts();
    loadReviews();

    setInterval(() => loadChatSessions(true), 5000);
    setInterval(refreshPresenceData, 15000);
  </script>
</body>
</html>
